import type { ActionAnnotations, ActionImportAnnotations, AnnotationAnnotations, ComplexTypeAnnotations, EntityContainerAnnotations, EntitySetAnnotations, EntityTypeAnnotations, EnumTypeAnnotations, FunctionAnnotations, FunctionImportAnnotations, IncludeAnnotations, NavigationPropertyAnnotations, ParameterAnnotations, PropertyAnnotations, ReferenceAnnotations, ReturnTypeAnnotations, SchemaAnnotations, SingletonAnnotations, TermAnnotations, TypeDefinitionAnnotations, PropertyValueAnnotations, RecordAnnotations, CollectionAnnotations } from './vocabularies/Edm_Types';
import type { AnnotationList, FullyQualifiedName, RawAnnotation, SimpleIdentifier } from './BaseEdm';
export declare type PropertyPath = {
    fullyQualifiedName: string;
    type: 'PropertyPath';
    value: string;
    $target: Property;
};
export declare type NavigationPropertyPath = {
    type: 'NavigationPropertyPath';
    value: string;
    $target: NavigationProperty;
};
export declare type AnnotationPath<P> = {
    type: 'AnnotationPath';
    value: string;
    $target: AnnotationTerm<P> & {
        term: string;
    };
};
declare type PrimitiveTypeCast<P, G> = (P extends boolean ? boolean | (Boolean & G) : never) | (P extends number ? number | (Number & G) : never) | (P extends string ? string | (String & G) : never) | (P & G);
export declare type AnnotationTerm<P> = PrimitiveTypeCast<P, {
    fullyQualifiedName: string;
    qualifier: string;
    annotations?: TermAnnotations & AnnotationAnnotations;
}>;
export declare type PathAnnotationExpression<P> = {
    type: 'Path';
    path: string;
    $target: P;
    getValue(): P;
};
export declare type ApplyAnnotationExpression<P> = {
    type: 'Apply';
    Apply: PropertyAnnotationValue<P>[];
    Function: 'odata.concat';
};
export declare type EqConditionalExpression = {
    $Eq: [ConditionalCheckOrValue, ConditionalCheckOrValue];
};
export declare type NeConditionalExpression = {
    $Ne: [ConditionalCheckOrValue, ConditionalCheckOrValue];
};
export declare type GtConditionalExpression = {
    $Gt: [ConditionalCheckOrValue, ConditionalCheckOrValue];
};
export declare type GeConditionalExpression = {
    $Ge: [ConditionalCheckOrValue, ConditionalCheckOrValue];
};
export declare type LtConditionalExpression = {
    $Lt: [ConditionalCheckOrValue, ConditionalCheckOrValue];
};
export declare type LeConditionalExpression = {
    $Le: [ConditionalCheckOrValue, ConditionalCheckOrValue];
};
export declare type AndConditionalExpression = {
    $And: [ConditionalCheckOrValue, ConditionalCheckOrValue];
};
export declare type OrConditionalExpression = {
    $Or: [ConditionalCheckOrValue, ConditionalCheckOrValue];
};
export declare type NotConditionalExpression = {
    $Not: ConditionalCheckOrValue;
};
export declare type PathConditionExpression<T> = {
    $Path: string;
};
export declare type ConditionalCheck = OrConditionalExpression | AndConditionalExpression | NotConditionalExpression | EqConditionalExpression | NeConditionalExpression | GtConditionalExpression | GeConditionalExpression | LtConditionalExpression | LeConditionalExpression;
export declare type ConditionalCheckOrValue = null | string | number | boolean | ConditionalCheck | PathConditionExpression<string | number | boolean>;
export declare type IfAnnotationExpressionValue<OutType> = [ConditionalCheck, OutType, OutType];
export declare type IfAnnotationExpression<P> = {
    type: 'If';
    If: IfAnnotationExpressionValue<P>;
    getValue(): P;
};
export declare type AndAnnotationExpression<P> = {
    type: 'And';
    And: AndConditionalExpression[];
};
export declare type OrAnnotationExpression<P> = {
    type: 'Or';
    Or: OrConditionalExpression[];
};
export declare type EqAnnotationExpression<P> = {
    type: 'Eq';
    Eq: EqConditionalExpression[];
};
export declare type NeAnnotationExpression<P> = {
    type: 'Ne';
    Ne: NeConditionalExpression[];
};
export declare type NotAnnotationExpression<P> = {
    type: 'Not';
    Not: NotConditionalExpression;
};
export declare type GtAnnotationExpression<P> = {
    type: 'Gt';
    Gt: GtConditionalExpression[];
};
export declare type GeAnnotationExpression<P> = {
    type: 'Ge';
    Ge: GeConditionalExpression[];
};
export declare type LtAnnotationExpression<P> = {
    type: 'Lt';
    Lt: LtConditionalExpression[];
};
export declare type LeAnnotationExpression<P> = {
    type: 'Le';
    Le: LeConditionalExpression[];
};
export declare type PropertyAnnotationValue<P> = P | PathAnnotationExpression<P> | ApplyAnnotationExpression<P> | AndAnnotationExpression<P> | OrAnnotationExpression<P> | EqAnnotationExpression<P> | NeAnnotationExpression<P> | NotAnnotationExpression<P> | GtAnnotationExpression<P> | GeAnnotationExpression<P> | LtAnnotationExpression<P> | LeAnnotationExpression<P> | IfAnnotationExpression<P>;
export declare type IDecimal = {
    isDecimal(): boolean;
    valueOf(): number;
    toString(): string;
};
export declare type InstancePath = string;
export declare type Byte = Number;
export declare type Int16 = Number;
export declare type Int32 = Number;
export declare type Int64 = Number;
export declare type Time = string;
export declare type Binary = string;
export declare type Decimal = IDecimal | Number;
export declare type Double = IDecimal | Number;
export declare type Date = string;
export declare type Guid = any;
export declare type Duration = any;
export declare type DateTimeOffset = any;
export declare type Untyped = any;
export declare type Stream = any;
export declare type GeographyPoint = any;
export declare type Geometry = any;
export declare type PrimitiveType = Binary | Boolean | Byte | Date | DateTimeOffset | Decimal | Double | Duration | Guid | Int16 | Int32 | Int64 | String | GeographyPoint;
export declare type EnumValue<P> = P | PathAnnotationExpression<P> | ApplyAnnotationExpression<P> | IfAnnotationExpression<P>;
export declare type String = InstanceType<StringConstructor>;
export declare type Boolean = InstanceType<BooleanConstructor>;
export declare type AnyAnnotation = EnumTypeAnnotations | PropertyValueAnnotations | IncludeAnnotations | ReferenceAnnotations | ActionAnnotations | FunctionImportAnnotations | ActionImportAnnotations | TypeDefinitionAnnotations | SingletonAnnotations | EntityContainerAnnotations | FunctionAnnotations | ReturnTypeAnnotations | ParameterAnnotations | ComplexTypeAnnotations | TermAnnotations | RecordAnnotations | SchemaAnnotations | AnnotationAnnotations | EntitySetAnnotations | EntityTypeAnnotations | PropertyAnnotations | NavigationPropertyAnnotations;
export declare type Property = {
    _type: 'Property';
    name: SimpleIdentifier;
    type: FullyQualifiedName;
    fullyQualifiedName: FullyQualifiedName;
    maxLength?: number;
    precision?: number;
    scale?: number;
    nullable?: boolean;
    defaultValue?: string | boolean | number;
    unicode?: boolean;
    annotations: PropertyAnnotations;
    targetType?: ComplexType | TypeDefinition;
    isKey: boolean;
};
export declare type RecordComplexType = {
    annotations?: RecordAnnotations;
    fullyQualifiedName: string;
};
export declare type ComplexType = {
    _type: 'ComplexType';
    name: SimpleIdentifier;
    fullyQualifiedName: FullyQualifiedName;
    properties: Property[];
    navigationProperties: NavigationProperty[];
    annotations: ComplexTypeAnnotations;
};
export declare type TypeDefinition = {
    _type: 'TypeDefinition';
    name: SimpleIdentifier;
    fullyQualifiedName: FullyQualifiedName;
    underlyingType: string;
    annotations: TypeDefinitionAnnotations;
};
export declare type NavigationProperty = SingleNavigationProperty | MultipleNavigationProperty;
export declare type ReferentialConstraint = {
    sourceTypeName: FullyQualifiedName;
    sourceProperty: SimpleIdentifier;
    targetTypeName: FullyQualifiedName;
    targetProperty: SimpleIdentifier;
};
export declare type BaseNavigationProperty = {
    _type: 'NavigationProperty';
    name: SimpleIdentifier;
    partner: string;
    fullyQualifiedName: FullyQualifiedName;
    targetTypeName: FullyQualifiedName;
    targetType: EntityType;
    annotations: NavigationPropertyAnnotations;
    isCollection: boolean;
    containsTarget: boolean;
    referentialConstraint: ReferentialConstraint[];
};
export declare type SingleNavigationProperty = BaseNavigationProperty & {
    isCollection: false;
    annotations: NavigationPropertyAnnotations;
};
export declare type MultipleNavigationProperty = BaseNavigationProperty & {
    isCollection: true;
    annotations: NavigationPropertyAnnotations | CollectionAnnotations;
};
export declare type EntityType = {
    _type: 'EntityType';
    fullyQualifiedName: FullyQualifiedName;
    entityProperties: Property[];
    keys: Property[];
    navigationProperties: NavigationProperty[];
    actions: Record<string, Action>;
    annotations: EntityTypeAnnotations;
    name: SimpleIdentifier;
    resolvePath(relativePath: string, includeVisitedObjects?: boolean): any;
};
export declare type EntitySet = {
    _type: 'EntitySet';
    name: SimpleIdentifier;
    entityTypeName: FullyQualifiedName;
    entityType: EntityType;
    fullyQualifiedName: SimpleIdentifier;
    navigationPropertyBinding: Record<string, EntitySet | Singleton>;
    annotations: EntitySetAnnotations;
};
export declare type Singleton = {
    _type: 'Singleton';
    name: SimpleIdentifier;
    entityTypeName: FullyQualifiedName;
    fullyQualifiedName: SimpleIdentifier;
    entityType: EntityType;
    nullable: boolean;
    navigationPropertyBinding: Record<string, Singleton | EntitySet>;
    annotations: SingletonAnnotations;
};
export declare type EntityContainer = {
    _type: 'EntityContainer';
    name?: string;
    fullyQualifiedName: string;
    annotations: EntityContainerAnnotations;
};
export declare type ActionParameter = {
    _type: 'ActionParameter';
    isCollection: boolean;
    name: string;
    fullyQualifiedName: string;
    type: string;
    annotations: ParameterAnnotations;
};
export declare type Action = {
    _type: 'Action';
    name: SimpleIdentifier;
    fullyQualifiedName: SimpleIdentifier;
    isBound: boolean;
    sourceType: string;
    returnType: string;
    isFunction: boolean;
    sourceEntityType?: EntityType;
    returnEntityType?: EntityType;
    annotations: ActionAnnotations;
    parameters: ActionParameter[];
};
/**
 * ActionImport or FunctionImport
 */
export declare type ActionImport = {
    _type: 'ActionImport';
    name: SimpleIdentifier;
    fullyQualifiedName: SimpleIdentifier;
    actionName: string;
    action?: Action;
};
export declare type ServiceObject = EntitySet | Singleton | EntityType | Property | ComplexType | NavigationProperty | Action | EntityContainer;
export declare type ServiceObjectAndAnnotation = ServiceObject | AnyAnnotation;
export declare type ResolutionTarget<T> = {
    target: null | T;
    objectPath: ServiceObjectAndAnnotation[];
};
export declare type Reference = {
    uri: string;
    alias: string;
    namespace: string;
};
export declare type ConvertedMetadata = {
    version: string;
    annotations: Record<string, AnnotationList[]>;
    namespace: string;
    actions: Action[];
    actionImports: ActionImport[];
    entityContainer: EntityContainer;
    complexTypes: ComplexType[];
    typeDefinitions: TypeDefinition[];
    entitySets: EntitySet[];
    singletons: Singleton[];
    entityTypes: EntityType[];
    references: Reference[];
    diagnostics: {
        message: string;
    }[];
    resolvePath: <T>(path: string, resolveDirectly?: boolean) => ResolutionTarget<T>;
};
declare type RemoveAnnotationAndType<T> = {
    [K in keyof Omit<T, 'annotations' | 'targetType' | 'isKey' | 'resolvePath' | 'entityType' | 'navigationProperties'>]: T[K] extends object ? T[K] extends Array<infer Item> ? RemoveAnnotationAndType<Item>[] : RemoveAnnotationAndType<T[K]> : T[K];
};
export declare type RawMetadata = {
    identification: string;
    version: string;
    schema: RawSchema;
    references: Reference[];
};
export declare type RawAssociation = {
    name: SimpleIdentifier;
    fullyQualifiedName: FullyQualifiedName;
    associationEnd: RawAssociationEnd[];
    referentialConstraints: ReferentialConstraint[];
};
export declare type RawAssociationSet = {
    name: SimpleIdentifier;
    fullyQualifiedName: FullyQualifiedName;
    association: string;
    associationEnd: RawAssociationSetEnd[];
};
export declare type RawAssociationEnd = {
    type: FullyQualifiedName;
    role: SimpleIdentifier;
    multiplicity: string;
};
export declare type RawAssociationSetEnd = {
    entitySet: FullyQualifiedName;
    role: SimpleIdentifier;
};
export declare type RawSchema = {
    namespace: string;
    associations: RawAssociation[];
    associationSets: RawAssociationSet[];
    annotations: {
        [id: string]: AnnotationList[];
    };
    entitySets: RawEntitySet[];
    singletons: RawSingleton[];
    complexTypes: RawComplexType[];
    typeDefinitions: RawTypeDefinition[];
    entityContainer: RawEntityContainer;
    actions: RawAction[];
    actionImports: RawActionImport[];
    entityTypes: RawEntityType[];
};
export declare type RawAction = RemoveAnnotationAndType<Action>;
export declare type RawActionImport = RemoveAnnotationAndType<ActionImport>;
export declare type RawEntityType = RemoveAnnotationAndType<EntityType> & {
    navigationProperties: (RawV2NavigationProperty | RawV4NavigationProperty)[];
};
export declare type RawEntitySet = RemoveAnnotationAndType<EntitySet>;
export declare type RawProperty = RemoveAnnotationAndType<Property>;
export declare type RawSingleton = RemoveAnnotationAndType<Singleton>;
export declare type RawEntityContainer = RemoveAnnotationAndType<EntityContainer>;
export declare type RawTypeDefinition = RemoveAnnotationAndType<TypeDefinition>;
export declare type RawComplexType = RemoveAnnotationAndType<ComplexType> & {
    navigationProperties: (RawV2NavigationProperty | RawV4NavigationProperty)[];
};
export declare type RawV2NavigationProperty = {
    _type: 'NavigationProperty';
    name: SimpleIdentifier;
    fullyQualifiedName: FullyQualifiedName;
    relationship: FullyQualifiedName;
    toRole: SimpleIdentifier;
    fromRole: SimpleIdentifier;
    referentialConstraint?: ReferentialConstraint[];
};
export declare type RawV4NavigationProperty = RemoveAnnotationAndType<BaseNavigationProperty>;
export declare type Annotation = RawAnnotation & {
    fullyQualifiedName: string;
};
export {};
