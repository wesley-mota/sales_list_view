import * as Core from "./Core";
import * as Aggregation from "./Aggregation";
import * as Common from "./Common";
import * as Edm from "../Edm";
import AnnotationTerm = Edm.AnnotationTerm;
import PropertyAnnotationValue = Edm.PropertyAnnotationValue;
import ComplexType = Edm.RecordComplexType;
/**
  A property holding the key of a dimension in an analytical context
*/
export declare type Dimension = {
    term: AnalyticsAnnotationTerms.Dimension;
} & AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
/**
  A property holding the numeric value of a measure in an analytical context
*/
export declare type Measure = {
    term: AnalyticsAnnotationTerms.Measure;
} & AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
/**
  The measure has non-negative and additive values; it can be used in whole-part charts, e.g. the Donut
*/
export declare type AccumulativeMeasure = {
    term: AnalyticsAnnotationTerms.AccumulativeMeasure;
} & AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
/**
  Number of properties in the entity instance that have been aggregated away
*/
export declare type RolledUpPropertyCount = {
    term: AnalyticsAnnotationTerms.RolledUpPropertyCount;
} & AnnotationTerm<Edm.Int16>;
/**
  
            URL to retrieve more detailed data related to a node of a recursive hierarchy.
            Annotations with this term MUST include a qualifier to select the hierarchy for which the drill URL is provided.
          
*/
export declare type DrillURL = {
    term: AnalyticsAnnotationTerms.DrillURL;
} & AnnotationTerm<PropertyAnnotationValue<Edm.String>>;
/**
   Processes or generates plan data. Its logic may have side-effects on entity sets.
          
*/
export declare type PlanningAction = {
    term: AnalyticsAnnotationTerms.PlanningAction;
} & AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
/**
  Dynamic properties for aggregate expressions with specified aggregation method defined on the annotated entity type.
*/
export declare type AggregatedProperties = {
    term: AnalyticsAnnotationTerms.AggregatedProperties;
} & AnnotationTerm<AggregatedPropertyTypeTypes[]>;
/**
  Dynamic property for aggregate expression with specified aggregation method defined on the annotated entity type.
*/
export declare type AggregatedProperty = {
    term: AnalyticsAnnotationTerms.AggregatedProperty;
} & AnnotationTerm<AggregatedPropertyTypeTypes>;
export declare type AggregatedPropertyType = ComplexType & {
    $Type: AnalyticsAnnotationTypes.AggregatedPropertyType;
    /**
        Name of the dynamic property holding the aggregated value.
    */
    Name: Common.SimpleIdentifier;
    /**
        Name of the standard or custom aggregation method to be applied.
    */
    AggregationMethod: PropertyAnnotationValue<Edm.String>;
    /**
        Property whose values shall be aggregated.
    */
    AggregatableProperty: Edm.PropertyPath;
};
/**
  Collection of properties that define an analytical context
*/
export declare type AnalyticalContext = {
    term: AnalyticsAnnotationTerms.AnalyticalContext;
} & AnnotationTerm<AnalyticalContextTypeTypes[]>;
/**
  Exactly one of `Property` and `DynamicProperty` must be present
*/
export declare type AnalyticalContextType = ComplexType & {
    $Type: AnalyticsAnnotationTypes.AnalyticalContextType;
    /**
        Property that is part of the analytical context
    */
    Property?: Edm.PropertyPath;
    /**
        Dynamic property introduced by annotations that is part of the analytical context
    */
    DynamicProperty?: Edm.AnnotationPath<AggregatedProperty | Aggregation.CustomAggregate>;
    /**
        The property holds the key of a dimension
    */
    Dimension: Core.Tag;
    /**
        The property holds the numeric value of a measure
    */
    Measure: Core.Tag;
    /**
        The measure has non-negative and additive values; it can be used in whole-part charts, e.g. the Donut
    */
    AccumulativeMeasure: Core.Tag;
};
export declare const enum AnalyticsAnnotationTerms {
    Dimension = "com.sap.vocabularies.Analytics.v1.Dimension",
    Measure = "com.sap.vocabularies.Analytics.v1.Measure",
    AccumulativeMeasure = "com.sap.vocabularies.Analytics.v1.AccumulativeMeasure",
    RolledUpPropertyCount = "com.sap.vocabularies.Analytics.v1.RolledUpPropertyCount",
    DrillURL = "com.sap.vocabularies.Analytics.v1.DrillURL",
    PlanningAction = "com.sap.vocabularies.Analytics.v1.PlanningAction",
    AggregatedProperties = "com.sap.vocabularies.Analytics.v1.AggregatedProperties",
    AggregatedProperty = "com.sap.vocabularies.Analytics.v1.AggregatedProperty",
    AnalyticalContext = "com.sap.vocabularies.Analytics.v1.AnalyticalContext"
}
export declare const enum AnalyticsAnnotationTypes {
    AggregatedPropertyType = "com.sap.vocabularies.Analytics.v1.AggregatedPropertyType",
    AnalyticalContextType = "com.sap.vocabularies.Analytics.v1.AnalyticalContextType"
}
export declare type AggregatedPropertyTypeTypes = AggregatedPropertyType;
export declare type AnalyticalContextTypeTypes = AnalyticalContextType;
