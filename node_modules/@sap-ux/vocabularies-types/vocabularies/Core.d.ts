import * as Edm from "../Edm";
import AnnotationTerm = Edm.AnnotationTerm;
import PropertyAnnotationValue = Edm.PropertyAnnotationValue;
import EnumValue = Edm.EnumValue;
import ComplexType = Edm.RecordComplexType;
/**
  A space-separated list of supported versions of the OData Protocol. Note that 4.0 is implied by 4.01 and does not need to be separately listed.
*/
export declare type ODataVersions = {
    term: CoreAnnotationTerms.ODataVersions;
} & AnnotationTerm<PropertyAnnotationValue<Edm.String>>;
/**
  Service-defined value representing the version of the schema. Services MAY use semantic versioning, but clients MUST NOT assume this is the case.
*/
export declare type SchemaVersion = {
    term: CoreAnnotationTerms.SchemaVersion;
} & AnnotationTerm<PropertyAnnotationValue<Edm.String>>;
/**
  List of revisions of a model element
*/
export declare type Revisions = {
    term: CoreAnnotationTerms.Revisions;
} & AnnotationTerm<RevisionTypeTypes[]>;
export declare type RevisionType = ComplexType & {
    $Type: CoreAnnotationTypes.RevisionType;
    /**
        The schema version with which this revision was first published
    */
    Version?: PropertyAnnotationValue<Edm.String>;
    /**
        The kind of revision
    */
    Kind: RevisionKind;
    /**
        Text describing the reason for the revision
    */
    Description: PropertyAnnotationValue<Edm.String>;
};
export declare const enum RevisionKind {
    /**
    Model element was added
    */
    /**
    undefined
    */
    Added = "Core.RevisionKind/Added",
    /**
    Model element was modified
    */
    /**
    undefined
    */
    Modified = "Core.RevisionKind/Modified",
    /**
    Model element was deprecated
    */
    /**
    undefined
    */
    Deprecated = "Core.RevisionKind/Deprecated"
}
/**
  A brief description of a model element
*/
export declare type Description = {
    term: CoreAnnotationTerms.Description;
} & AnnotationTerm<PropertyAnnotationValue<Edm.String>>;
/**
  A long description of a model element
*/
export declare type LongDescription = {
    term: CoreAnnotationTerms.LongDescription;
} & AnnotationTerm<PropertyAnnotationValue<Edm.String>>;
/**
  Link to related information
*/
export declare type Links = {
    term: CoreAnnotationTerms.Links;
} & AnnotationTerm<LinkTypes[]>;
/**
  The Link term is inspired by the `atom:link` element, see [RFC4287](https://tools.ietf.org/html/rfc4287#section-4.2.7), and the `Link` HTTP header, see [RFC5988](https://tools.ietf.org/html/rfc5988)
*/
export declare type Link = ComplexType & {
    $Type: CoreAnnotationTypes.Link;
    /**
        Link relation type, see [IANA Link Relations](http://www.iana.org/assignments/link-relations/link-relations.xhtml)
    */
    rel: PropertyAnnotationValue<Edm.String>;
    /**
        URL of related information
    */
    href: PropertyAnnotationValue<Edm.String>;
};
/**
  Example for an instance of the annotated model element
*/
export declare type Example = {
    term: CoreAnnotationTerms.Example;
} & AnnotationTerm<ExampleValueTypes>;
export declare type ExampleValue = ComplexType & {
    $Type: CoreAnnotationTypes.ExampleValue;
    /**
        Description of the example value
    */
    Description?: PropertyAnnotationValue<Edm.String>;
};
export declare type PrimitiveExampleValue = ComplexType & Omit<ExampleValue, '$Type'> & {
    $Type: CoreAnnotationTypes.PrimitiveExampleValue;
    /**
        Example value for the custom parameter
    */
    Value: PropertyAnnotationValue<Edm.PrimitiveType>;
};
export declare type ComplexExampleValue = ComplexType & Omit<ExampleValue, '$Type'> & {
    $Type: CoreAnnotationTypes.ComplexExampleValue;
    /**
        Example value for the custom parameter
    */
    Value: PropertyAnnotationValue<Edm.ComplexType>;
};
export declare type EntityExampleValue = ComplexType & Omit<ExampleValue, '$Type'> & {
    $Type: CoreAnnotationTypes.EntityExampleValue;
    /**
        Example value for the custom parameter
    */
    Value: PropertyAnnotationValue<Edm.EntityType>;
};
export declare type ExternalExampleValue = ComplexType & Omit<ExampleValue, '$Type'> & {
    $Type: CoreAnnotationTypes.ExternalExampleValue;
    /**
        Url reference to the value in its literal format
    */
    ExternalValue: PropertyAnnotationValue<Edm.String>;
};
/**
  Instance annotation for warning and info messages
*/
export declare type Messages = {
    term: CoreAnnotationTerms.Messages;
} & AnnotationTerm<MessageTypeTypes[]>;
export declare type MessageType = ComplexType & {
    $Type: CoreAnnotationTypes.MessageType;
    /**
        Machine-readable, language-independent message code
    */
    code: PropertyAnnotationValue<Edm.String>;
    /**
        Human-readable, language-dependent message text
    */
    message: PropertyAnnotationValue<Edm.String>;
    /**
        Severity of the message
    */
    severity: MessageSeverity;
    /**
        A path to the target of the message detail, relative to the annotated instance
    */
    target?: PropertyAnnotationValue<Edm.String>;
    /**
        List of detail messages
    */
    details: MessageTypeTypes[];
};
export declare type MessageSeverity = Edm.String;
/**
  The annotated value is problematic
*/
export declare type ValueException = {
    term: CoreAnnotationTerms.ValueException;
} & AnnotationTerm<ValueExceptionTypeTypes>;
export declare type ExceptionType = ComplexType & {
    $Type: CoreAnnotationTypes.ExceptionType;
    /**
        Information about the exception
    */
    info?: MessageTypeTypes;
};
export declare type ValueExceptionType = ComplexType & Omit<ExceptionType, '$Type'> & {
    $Type: CoreAnnotationTypes.ValueExceptionType;
    /**
        String representation of the exact value
    */
    value?: PropertyAnnotationValue<Edm.String>;
};
/**
  The annotated instance within a success payload is problematic
*/
export declare type ResourceException = {
    term: CoreAnnotationTerms.ResourceException;
} & AnnotationTerm<ResourceExceptionTypeTypes>;
export declare type ResourceExceptionType = ComplexType & Omit<ExceptionType, '$Type'> & {
    $Type: CoreAnnotationTypes.ResourceExceptionType;
    /**
        A GET request to this URL retries retrieving the problematic instance
    */
    retryLink?: PropertyAnnotationValue<Edm.String>;
};
/**
  A modification operation failed on the annotated instance or collection within a success payload
*/
export declare type DataModificationException = {
    term: CoreAnnotationTerms.DataModificationException;
} & AnnotationTerm<DataModificationExceptionTypeTypes>;
export declare type DataModificationExceptionType = ComplexType & Omit<ExceptionType, '$Type'> & {
    $Type: CoreAnnotationTypes.DataModificationExceptionType;
    /**
        The kind of modification operation that failed
    */
    failedOperation: DataModificationOperationKind;
    /**
        Response code of the failed operation, e.g. 424 for a failed dependency
    */
    responseCode?: PropertyAnnotationValue<Edm.Int16>;
};
export declare const enum DataModificationOperationKind {
    /**
    Insert new instance
    */
    /**
    undefined
    */
    insert = "Core.DataModificationOperationKind/insert",
    /**
    Update existing instance
    */
    /**
    undefined
    */
    update = "Core.DataModificationOperationKind/update",
    /**
    Insert new instance or update it if it already exists
    */
    /**
    undefined
    */
    upsert = "Core.DataModificationOperationKind/upsert",
    /**
    Delete existing instance
    */
    /**
    undefined
    */
    delete = "Core.DataModificationOperationKind/delete",
    /**
    Invoke action or function
    */
    /**
    undefined
    */
    invoke = "Core.DataModificationOperationKind/invoke",
    /**
    Add link between entities
    */
    /**
    undefined
    */
    link = "Core.DataModificationOperationKind/link",
    /**
    Remove link between entities
    */
    /**
    undefined
    */
    unlink = "Core.DataModificationOperationKind/unlink"
}
/**
  Properties and terms annotated with this term are language-dependent
*/
export declare type IsLanguageDependent = {
    term: CoreAnnotationTerms.IsLanguageDependent;
} & AnnotationTerm<PropertyAnnotationValue<Tag>>;
/**
  This is the type to use for all tagging terms
*/
export declare type Tag = Edm.Boolean;
/**
  Terms annotated with this term can only be applied to elements that have a type that is identical to or derived from the given type name
*/
export declare type RequiresType = {
    term: CoreAnnotationTerms.RequiresType;
} & AnnotationTerm<PropertyAnnotationValue<Edm.String>>;
/**
  The target path of an annotation with the tagged term MUST start with an entity container or the annotation MUST be embedded within an entity container, entity set or singleton
*/
export declare type AppliesViaContainer = {
    term: CoreAnnotationTerms.AppliesViaContainer;
} & AnnotationTerm<PropertyAnnotationValue<Tag>>;
/**
  Resource path for entity container child, can be relative to xml:base and the request URL
*/
export declare type ResourcePath = {
    term: CoreAnnotationTerms.ResourcePath;
} & AnnotationTerm<PropertyAnnotationValue<Edm.String>>;
/**
  Entity-ids are URLs that locate the identified entity
*/
export declare type DereferenceableIDs = {
    term: CoreAnnotationTerms.DereferenceableIDs;
} & AnnotationTerm<PropertyAnnotationValue<Tag>>;
/**
  Entity-ids follow OData URL conventions
*/
export declare type ConventionalIDs = {
    term: CoreAnnotationTerms.ConventionalIDs;
} & AnnotationTerm<PropertyAnnotationValue<Tag>>;
/**
  Permissions for accessing a resource
*/
export declare type Permissions = EnumValue<Permission>;
export declare const enum Permission {
    /**
    No permissions
    */
    /**
    undefined
    */
    None = "Core.Permission/None",
    /**
    Read permission
    */
    /**
    undefined
    */
    Read = "Core.Permission/Read",
    /**
    Write permission
    */
    /**
    undefined
    */
    Write = "Core.Permission/Write",
    /**
    Read and write permission
    */
    /**
    undefined
    */
    ReadWrite = "Core.Permission/ReadWrite",
    /**
    Permission to invoke actions
    */
    /**
    undefined
    */
    Invoke = "Core.Permission/Invoke"
}
/**
  A unique identifier for nested entities within a request.
*/
export declare type ContentID = {
    term: CoreAnnotationTerms.ContentID;
} & AnnotationTerm<PropertyAnnotationValue<Edm.String>>;
/**
  Functions, actions and types in this namespace can be referenced in URLs with or without namespace- or alias- qualification.
*/
export declare type DefaultNamespace = {
    term: CoreAnnotationTerms.DefaultNamespace;
} & AnnotationTerm<PropertyAnnotationValue<Tag>>;
/**
  A value for this non-key property can be provided by the client on insert and remains unchanged on update
*/
export declare type Immutable = {
    term: CoreAnnotationTerms.Immutable;
} & AnnotationTerm<PropertyAnnotationValue<Tag>>;
/**
  A value for this property is generated on both insert and update
*/
export declare type Computed = {
    term: CoreAnnotationTerms.Computed;
} & AnnotationTerm<PropertyAnnotationValue<Tag>>;
/**
  A value for this property can be provided by the client on insert and update. If no value is provided on insert, a non-static default value is generated
*/
export declare type ComputedDefaultValue = {
    term: CoreAnnotationTerms.ComputedDefaultValue;
} & AnnotationTerm<PropertyAnnotationValue<Tag>>;
/**
  Properties and terms annotated with this term MUST contain a valid URL
*/
export declare type IsURL = {
    term: CoreAnnotationTerms.IsURL;
} & AnnotationTerm<PropertyAnnotationValue<Tag>>;
/**
  Lists the MIME types acceptable for the annotated entity type marked with HasStream="true" or the annotated binary, stream, or string property or term
*/
export declare type AcceptableMediaTypes = {
    term: CoreAnnotationTerms.AcceptableMediaTypes;
} & AnnotationTerm<PropertyAnnotationValue<Edm.String[]>>;
/**
  The media type of the media stream of the annotated entity type marked with HasStream="true" or the annotated binary, stream, or string property or term
*/
export declare type MediaType = {
    term: CoreAnnotationTerms.MediaType;
} & AnnotationTerm<PropertyAnnotationValue<Edm.String>>;
/**
  Properties and terms annotated with this term MUST contain a valid MIME type
*/
export declare type IsMediaType = {
    term: CoreAnnotationTerms.IsMediaType;
} & AnnotationTerm<PropertyAnnotationValue<Tag>>;
/**
  The content disposition of the media stream of the annotated entity type marked with HasStream="true" or the annotated binary, stream, or string property or term
*/
export declare type ContentDisposition = {
    term: CoreAnnotationTerms.ContentDisposition;
} & AnnotationTerm<ContentDispositionTypeTypes>;
export declare type ContentDispositionType = ComplexType & {
    $Type: CoreAnnotationTypes.ContentDispositionType;
    /**
        The disposition type of the binary or stream value, see [RFC 6266, Disposition Type](https://datatracker.ietf.org/doc/html/rfc6266#section-4.2)
    */
    Type: PropertyAnnotationValue<Edm.String>;
    /**
        The proposed filename for downloading the binary or stream value, see [RFC 6266, Disposition Parameter: 'Filename'](https://datatracker.ietf.org/doc/html/rfc6266#section-4.3)
    */
    Filename?: PropertyAnnotationValue<Edm.String>;
};
/**
  Data modification requires the use of ETags. A non-empty collection contains the set of properties that are used to compute the ETag. An empty collection means that the service won't tell how it computes the ETag
*/
export declare type OptimisticConcurrency = {
    term: CoreAnnotationTerms.OptimisticConcurrency;
} & AnnotationTerm<Edm.PropertyPath[]>;
/**
  Instances of this type may contain properties in addition to those declared in $metadata
*/
export declare type AdditionalProperties = {
    term: CoreAnnotationTerms.AdditionalProperties;
} & AnnotationTerm<PropertyAnnotationValue<Tag>>;
/**
  The service will automatically expand this stream property, navigation property, or the media stream of this media entity type even if not requested with $expand
*/
export declare type AutoExpand = {
    term: CoreAnnotationTerms.AutoExpand;
} & AnnotationTerm<PropertyAnnotationValue<Tag>>;
/**
  The service will automatically expand this navigation property as entity references even if not requested with $expand=.../$ref
*/
export declare type AutoExpandReferences = {
    term: CoreAnnotationTerms.AutoExpandReferences;
} & AnnotationTerm<PropertyAnnotationValue<Tag>>;
/**
  A collection of qualified type names outside of the type hierarchy that instances of this type might be addressable as by using a type-cast segment.
*/
export declare type MayImplement = {
    term: CoreAnnotationTerms.MayImplement;
} & AnnotationTerm<PropertyAnnotationValue<QualifiedTypeName[]>>;
/**
  The qualified name of a term in scope.
*/
export declare type QualifiedTermName = Edm.String;
/**
  The qualified name of a type in scope.
*/
export declare type QualifiedTypeName = Edm.String;
/**
  The qualified name of an action in scope.
*/
export declare type QualifiedActionName = Edm.String;
/**
  Collection has a stable order. Ordered collections of primitive or complex types can be indexed by ordinal.
*/
export declare type Ordered = {
    term: CoreAnnotationTerms.Ordered;
} & AnnotationTerm<PropertyAnnotationValue<Tag>>;
/**
  Items can be inserted at a given ordinal index.
*/
export declare type PositionalInsert = {
    term: CoreAnnotationTerms.PositionalInsert;
} & AnnotationTerm<PropertyAnnotationValue<Tag>>;
/**
  Communicates available alternate keys
*/
export declare type AlternateKeys = {
    term: CoreAnnotationTerms.AlternateKeys;
} & AnnotationTerm<AlternateKeyTypes[]>;
export declare type AlternateKey = ComplexType & {
    $Type: CoreAnnotationTypes.AlternateKey;
    /**
        The set of properties that make up this key
    */
    Key: PropertyRefTypes[];
};
export declare type PropertyRef = ComplexType & {
    $Type: CoreAnnotationTypes.PropertyRef;
    /**
        A path expression resolving to a primitive property of the entity type itself or to a primitive property of a complex or navigation property (recursively) of the entity type. The names of the properties in the path are joined together by forward slashes.
    */
    Name: Edm.PropertyPath;
    /**
        A SimpleIdentifier that MUST be unique within the set of aliases, structural and navigation properties of the containing entity type that MUST be used in the key predicate of URLs
    */
    Alias: PropertyAnnotationValue<Edm.String>;
};
/**
  A dictionary of name-value pairs. Names must be valid property names, values may be restricted to a list of types via an annotation with term `Validation.OpenPropertyTypeConstraint`.
*/
export declare type Dictionary = ComplexType & {
    $Type: CoreAnnotationTypes.Dictionary;
};
/**
  Supplying a value for the action or function parameter is optional.
*/
export declare type OptionalParameter = {
    term: CoreAnnotationTerms.OptionalParameter;
} & AnnotationTerm<OptionalParameterTypeTypes>;
export declare type OptionalParameterType = ComplexType & {
    $Type: CoreAnnotationTypes.OptionalParameterType;
    /**
        Default value for an optional parameter of primitive or enumeration type, using the same rules as the `cast` function in URLs.
    */
    DefaultValue?: PropertyAnnotationValue<Edm.String>;
};
/**
  Action or function is available
*/
export declare type OperationAvailable = {
    term: CoreAnnotationTerms.OperationAvailable;
} & AnnotationTerm<Edm.Boolean>;
/**
  A string representing a Local Date-Time value with no offset.
*/
export declare type LocalDateTime = Edm.String;
/**
  A symbolic name for a model element
*/
export declare type SymbolicName = {
    term: CoreAnnotationTerms.SymbolicName;
} & AnnotationTerm<PropertyAnnotationValue<SimpleIdentifier>>;
/**
  A [simple identifier](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_SimpleIdentifier)
*/
export declare type SimpleIdentifier = Edm.String;
/**
  A [Feature Object](https://datatracker.ietf.org/doc/html/rfc7946#section-3.2) represents a spatially bounded thing
*/
export declare type GeometryFeature = {
    term: CoreAnnotationTerms.GeometryFeature;
} & AnnotationTerm<GeometryFeatureTypeTypes>;
/**
  A [Feature Object](https://datatracker.ietf.org/doc/html/rfc7946#section-3.2) represents a spatially bounded thing
*/
export declare type GeometryFeatureType = ComplexType & {
    $Type: CoreAnnotationTypes.GeometryFeatureType;
    /**
        Location of the Feature
    */
    geometry?: PropertyAnnotationValue<Edm.Geometry>;
    /**
        Properties of the Feature
    */
    properties?: DictionaryTypes;
    /**
        Commonly used identifer for a Feature
    */
    id?: PropertyAnnotationValue<Edm.String>;
};
export declare const enum CoreAnnotationTerms {
    ODataVersions = "Org.OData.Core.V1.ODataVersions",
    SchemaVersion = "Org.OData.Core.V1.SchemaVersion",
    Revisions = "Org.OData.Core.V1.Revisions",
    Description = "Org.OData.Core.V1.Description",
    LongDescription = "Org.OData.Core.V1.LongDescription",
    Links = "Org.OData.Core.V1.Links",
    Example = "Org.OData.Core.V1.Example",
    Messages = "Org.OData.Core.V1.Messages",
    ValueException = "Org.OData.Core.V1.ValueException",
    ResourceException = "Org.OData.Core.V1.ResourceException",
    DataModificationException = "Org.OData.Core.V1.DataModificationException",
    IsLanguageDependent = "Org.OData.Core.V1.IsLanguageDependent",
    RequiresType = "Org.OData.Core.V1.RequiresType",
    AppliesViaContainer = "Org.OData.Core.V1.AppliesViaContainer",
    ResourcePath = "Org.OData.Core.V1.ResourcePath",
    DereferenceableIDs = "Org.OData.Core.V1.DereferenceableIDs",
    ConventionalIDs = "Org.OData.Core.V1.ConventionalIDs",
    Permissions = "Org.OData.Core.V1.Permissions",
    ContentID = "Org.OData.Core.V1.ContentID",
    DefaultNamespace = "Org.OData.Core.V1.DefaultNamespace",
    Immutable = "Org.OData.Core.V1.Immutable",
    Computed = "Org.OData.Core.V1.Computed",
    ComputedDefaultValue = "Org.OData.Core.V1.ComputedDefaultValue",
    IsURL = "Org.OData.Core.V1.IsURL",
    AcceptableMediaTypes = "Org.OData.Core.V1.AcceptableMediaTypes",
    MediaType = "Org.OData.Core.V1.MediaType",
    IsMediaType = "Org.OData.Core.V1.IsMediaType",
    ContentDisposition = "Org.OData.Core.V1.ContentDisposition",
    OptimisticConcurrency = "Org.OData.Core.V1.OptimisticConcurrency",
    AdditionalProperties = "Org.OData.Core.V1.AdditionalProperties",
    AutoExpand = "Org.OData.Core.V1.AutoExpand",
    AutoExpandReferences = "Org.OData.Core.V1.AutoExpandReferences",
    MayImplement = "Org.OData.Core.V1.MayImplement",
    Ordered = "Org.OData.Core.V1.Ordered",
    PositionalInsert = "Org.OData.Core.V1.PositionalInsert",
    AlternateKeys = "Org.OData.Core.V1.AlternateKeys",
    OptionalParameter = "Org.OData.Core.V1.OptionalParameter",
    OperationAvailable = "Org.OData.Core.V1.OperationAvailable",
    SymbolicName = "Org.OData.Core.V1.SymbolicName",
    GeometryFeature = "Org.OData.Core.V1.GeometryFeature"
}
export declare const enum CoreAnnotationTypes {
    RevisionType = "Org.OData.Core.V1.RevisionType",
    Link = "Org.OData.Core.V1.Link",
    ExampleValue = "Org.OData.Core.V1.ExampleValue",
    PrimitiveExampleValue = "Org.OData.Core.V1.PrimitiveExampleValue",
    ComplexExampleValue = "Org.OData.Core.V1.ComplexExampleValue",
    EntityExampleValue = "Org.OData.Core.V1.EntityExampleValue",
    ExternalExampleValue = "Org.OData.Core.V1.ExternalExampleValue",
    MessageType = "Org.OData.Core.V1.MessageType",
    ExceptionType = "Org.OData.Core.V1.ExceptionType",
    ValueExceptionType = "Org.OData.Core.V1.ValueExceptionType",
    ResourceExceptionType = "Org.OData.Core.V1.ResourceExceptionType",
    DataModificationExceptionType = "Org.OData.Core.V1.DataModificationExceptionType",
    ContentDispositionType = "Org.OData.Core.V1.ContentDispositionType",
    AlternateKey = "Org.OData.Core.V1.AlternateKey",
    PropertyRef = "Org.OData.Core.V1.PropertyRef",
    Dictionary = "Org.OData.Core.V1.Dictionary",
    OptionalParameterType = "Org.OData.Core.V1.OptionalParameterType",
    GeometryFeatureType = "Org.OData.Core.V1.GeometryFeatureType"
}
export declare type RevisionTypeTypes = RevisionType;
export declare type LinkTypes = Link;
export declare type ExampleValueTypes = ExampleValue | PrimitiveExampleValueTypes | ComplexExampleValueTypes | EntityExampleValueTypes | ExternalExampleValueTypes;
export declare type PrimitiveExampleValueTypes = PrimitiveExampleValue;
export declare type ComplexExampleValueTypes = ComplexExampleValue;
export declare type EntityExampleValueTypes = EntityExampleValue;
export declare type ExternalExampleValueTypes = ExternalExampleValue;
export declare type MessageTypeTypes = MessageType;
export declare type ExceptionTypeTypes = ValueExceptionTypeTypes | ResourceExceptionTypeTypes | DataModificationExceptionTypeTypes;
export declare type ValueExceptionTypeTypes = ValueExceptionType;
export declare type ResourceExceptionTypeTypes = ResourceExceptionType;
export declare type DataModificationExceptionTypeTypes = DataModificationExceptionType;
export declare type ContentDispositionTypeTypes = ContentDispositionType;
export declare type AlternateKeyTypes = AlternateKey;
export declare type PropertyRefTypes = PropertyRef;
export declare type DictionaryTypes = Dictionary;
export declare type OptionalParameterTypeTypes = OptionalParameterType;
export declare type GeometryFeatureTypeTypes = GeometryFeatureType;
