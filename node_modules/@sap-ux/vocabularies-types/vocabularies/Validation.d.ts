import * as Core from "./Core";
import * as Edm from "../Edm";
import AnnotationTerm = Edm.AnnotationTerm;
import PropertyAnnotationValue = Edm.PropertyAnnotationValue;
import ComplexType = Edm.RecordComplexType;
/**
  The pattern that a string property, parameter, or term must match. This SHOULD be a valid regular expression, according to the ECMA 262 regular expression dialect.
*/
export declare type Pattern = {
    term: ValidationAnnotationTerms.Pattern;
} & AnnotationTerm<PropertyAnnotationValue<Edm.String>>;
/**
  Minimum value that a property, parameter, or term can have.
*/
export declare type Minimum = {
    term: ValidationAnnotationTerms.Minimum;
} & AnnotationTerm<Edm.PrimitiveType>;
/**
  Maximum value that a property, parameter, or term can have.
*/
export declare type Maximum = {
    term: ValidationAnnotationTerms.Maximum;
} & AnnotationTerm<Edm.PrimitiveType>;
/**
  Tags a Minimum or Maximum as exclusive, i.e. an open interval boundary.
*/
export declare type Exclusive = {
    term: ValidationAnnotationTerms.Exclusive;
} & AnnotationTerm<PropertyAnnotationValue<Core.Tag>>;
/**
  A collection of valid values for the annotated property, parameter, or type definition
*/
export declare type AllowedValues = {
    term: ValidationAnnotationTerms.AllowedValues;
} & AnnotationTerm<AllowedValueTypes[]>;
export declare type AllowedValue = ComplexType & {
    $Type: ValidationAnnotationTypes.AllowedValue;
    /**
        An allowed value for the property, parameter, or type definition
    */
    Value?: PropertyAnnotationValue<Edm.PrimitiveType>;
};
/**
  The value of the annotated property, parameter, or term must be an integer multiple of this positive value. For temporal types, the value is measured in seconds.
*/
export declare type MultipleOf = {
    term: ValidationAnnotationTerms.MultipleOf;
} & AnnotationTerm<Edm.Decimal>;
/**
  Condition that the annotation target has to fulfill
*/
export declare type Constraint = {
    term: ValidationAnnotationTerms.Constraint;
} & AnnotationTerm<ConstraintTypeTypes>;
export declare type ConstraintType = ComplexType & {
    $Type: ValidationAnnotationTypes.ConstraintType;
    /**
        Human-readable message that can be shown to end users if the constraint is not fulfilled
    */
    FailureMessage?: PropertyAnnotationValue<Edm.String>;
    /**
        Value MUST be a dynamic expression that evaluates to true if and only if the constraint is fulfilled
    */
    Condition: PropertyAnnotationValue<Edm.Boolean>;
};
/**
  A list of constraints describing that entities related via one navigation property MUST also be related via another, collection-valued navigation property. The same `path` value MUST NOT occur more than once.
*/
export declare type ItemsOf = {
    term: ValidationAnnotationTerms.ItemsOf;
} & AnnotationTerm<ItemsOfTypeTypes[]>;
/**
  Entities related via the single- or collection-valued navigation property identified by `path` are also related via the collection-valued navigation property identified by `target`.
*/
export declare type ItemsOfType = ComplexType & {
    $Type: ValidationAnnotationTypes.ItemsOfType;
    /**
        A path to a single- or collection-valued navigation property
    */
    path: Edm.NavigationPropertyPath;
    /**
        A path to a collection-valued navigation property
    */
    target: Edm.NavigationPropertyPath;
};
/**
  Dynamic properties added to the annotated open structured type are restricted to the listed types.
*/
export declare type OpenPropertyTypeConstraint = {
    term: ValidationAnnotationTerms.OpenPropertyTypeConstraint;
} & AnnotationTerm<PropertyAnnotationValue<SingleOrCollectionType[]>>;
/**
  Values are restricted to types that are both identical to or derived from the declared type and a type listed in this collection.
*/
export declare type DerivedTypeConstraint = {
    term: ValidationAnnotationTerms.DerivedTypeConstraint;
} & AnnotationTerm<PropertyAnnotationValue<SingleOrCollectionType[]>>;
/**
  The qualified name of a type in scope, optionally wrapped in `Collection()` to denote a collection of instances of the type
*/
export declare type SingleOrCollectionType = Edm.String;
/**
  Annotate a term of type Edm.AnnotationPath, or a property of type Edm.AnnotationPath that is used within a structured term, to restrict the terms that can be targeted by the path.
*/
export declare type AllowedTerms = {
    term: ValidationAnnotationTerms.AllowedTerms;
} & AnnotationTerm<Core.QualifiedTermName[]>;
/**
  Names of specific terms that are applicable and may be applied in the current context. This annotation does not restrict the use of other terms.
*/
export declare type ApplicableTerms = {
    term: ValidationAnnotationTerms.ApplicableTerms;
} & AnnotationTerm<Core.QualifiedTermName[]>;
/**
  The annotated collection must have at most the specified number of items.
*/
export declare type MaxItems = {
    term: ValidationAnnotationTerms.MaxItems;
} & AnnotationTerm<Edm.Int64>;
/**
  The annotated collection must have at least the specified number of items.
*/
export declare type MinItems = {
    term: ValidationAnnotationTerms.MinItems;
} & AnnotationTerm<Edm.Int64>;
export declare const enum ValidationAnnotationTerms {
    Pattern = "Org.OData.Validation.V1.Pattern",
    Minimum = "Org.OData.Validation.V1.Minimum",
    Maximum = "Org.OData.Validation.V1.Maximum",
    Exclusive = "Org.OData.Validation.V1.Exclusive",
    AllowedValues = "Org.OData.Validation.V1.AllowedValues",
    MultipleOf = "Org.OData.Validation.V1.MultipleOf",
    Constraint = "Org.OData.Validation.V1.Constraint",
    ItemsOf = "Org.OData.Validation.V1.ItemsOf",
    OpenPropertyTypeConstraint = "Org.OData.Validation.V1.OpenPropertyTypeConstraint",
    DerivedTypeConstraint = "Org.OData.Validation.V1.DerivedTypeConstraint",
    AllowedTerms = "Org.OData.Validation.V1.AllowedTerms",
    ApplicableTerms = "Org.OData.Validation.V1.ApplicableTerms",
    MaxItems = "Org.OData.Validation.V1.MaxItems",
    MinItems = "Org.OData.Validation.V1.MinItems"
}
export declare const enum ValidationAnnotationTypes {
    AllowedValue = "Org.OData.Validation.V1.AllowedValue",
    ConstraintType = "Org.OData.Validation.V1.ConstraintType",
    ItemsOfType = "Org.OData.Validation.V1.ItemsOfType"
}
export declare type AllowedValueTypes = AllowedValue;
export declare type ConstraintTypeTypes = ConstraintType;
export declare type ItemsOfTypeTypes = ItemsOfType;
