"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convert = void 0;
const utils_1 = require("./utils");
/**
 * Symbol to extend an annotation with the reference to its target.
 */
const ANNOTATION_TARGET = Symbol('Annotation Target');
/**
 * Append an object to the list of visited objects if it is different from the last object in the list.
 *
 * @param objectPath    The list of visited objects
 * @param visitedObject The object
 * @returns The list of visited objects
 */
function appendObjectPath(objectPath, visitedObject) {
    if (objectPath[objectPath.length - 1] !== visitedObject) {
        objectPath.push(visitedObject);
    }
    return objectPath;
}
/**
 * Resolves a (possibly relative) path.
 *
 * @param converter         Converter
 * @param startElement      The starting point in case of relative path resolution
 * @param path              The path to resolve
 * @param annotationsTerm   Only for error reporting: The annotation term
 * @returns An object containing the resolved target and the elements that were visited while getting to the target.
 */
function resolveTarget(converter, startElement, path, annotationsTerm) {
    var _a;
    // absolute paths always start at the entity container
    if (path.startsWith('/')) {
        path = path.substring(1);
        startElement = undefined; // will resolve to the entity container (see below)
    }
    const pathSegments = path.split('/').reduce((targetPath, segment) => {
        if (segment.includes('@')) {
            // Separate out the annotation
            const [pathPart, annotationPart] = (0, utils_1.splitAtFirst)(segment, '@');
            targetPath.push(pathPart);
            targetPath.push(`@${annotationPart}`);
        }
        else {
            targetPath.push(segment);
        }
        return targetPath;
    }, []);
    // determine the starting point for the resolution
    if (startElement === undefined) {
        // no starting point given: start at the entity container
        startElement = converter.getConvertedEntityContainer();
    }
    else if (startElement[ANNOTATION_TARGET] !== undefined) {
        // annotation: start at the annotation target
        startElement = startElement[ANNOTATION_TARGET];
    }
    else if (startElement._type === 'Property') {
        // property: start at the entity type or complex type the property belongs to
        const parentElementFQN = (0, utils_1.substringBeforeFirst)(startElement.fullyQualifiedName, '/');
        startElement =
            (_a = converter.getConvertedEntityType(parentElementFQN)) !== null && _a !== void 0 ? _a : converter.getConvertedComplexType(parentElementFQN);
    }
    const result = pathSegments.reduce((current, segment) => {
        var _a, _b, _c, _d, _e;
        const error = (message) => {
            current.messages.push({ message });
            current.target = undefined;
            return current;
        };
        if (current.target === undefined) {
            return current;
        }
        current.objectPath = appendObjectPath(current.objectPath, current.target);
        // Annotation
        if (segment.startsWith('@') && segment !== '@$ui5.overload') {
            const [vocabularyAlias, term] = converter.splitTerm(segment);
            const annotation = (_a = current.target.annotations[vocabularyAlias.substring(1)]) === null || _a === void 0 ? void 0 : _a[term];
            if (annotation !== undefined) {
                current.target = annotation;
                return current;
            }
            return error(`Annotation '${segment.substring(1)}' not found on ${current.target._type} '${current.target.fullyQualifiedName}'`);
        }
        // $Path / $AnnotationPath syntax
        if (current.target.$target) {
            let subPath;
            if (segment === '$AnnotationPath') {
                subPath = current.target.value;
            }
            else if (segment === '$Path') {
                subPath = current.target.path;
            }
            if (subPath !== undefined) {
                const subTarget = resolveTarget(converter, current.target[ANNOTATION_TARGET], subPath);
                subTarget.objectPath.forEach((visitedSubObject) => {
                    if (!current.objectPath.includes(visitedSubObject)) {
                        current.objectPath = appendObjectPath(current.objectPath, visitedSubObject);
                    }
                });
                current.target = subTarget.target;
                current.objectPath = appendObjectPath(current.objectPath, current.target);
                return current;
            }
        }
        // traverse based on the element type
        switch ((_b = current.target) === null || _b === void 0 ? void 0 : _b._type) {
            case 'EntityContainer':
                {
                    const thisElement = current.target;
                    if (segment === '' || segment === thisElement.fullyQualifiedName) {
                        return current;
                    }
                    // next element: EntitySet, Singleton or ActionImport?
                    const nextElement = (_d = (_c = thisElement.entitySets.by_name(segment)) !== null && _c !== void 0 ? _c : thisElement.singletons.by_name(segment)) !== null && _d !== void 0 ? _d : thisElement.actionImports.by_name(segment);
                    if (nextElement) {
                        current.target = nextElement;
                        return current;
                    }
                }
                break;
            case 'EntitySet':
            case 'Singleton': {
                const thisElement = current.target;
                if (segment === '' || segment === '$Type') {
                    // Empty Path after an EntitySet or Singleton means EntityType
                    current.target = thisElement.entityType;
                    return current;
                }
                if (segment === '$') {
                    return current;
                }
                if (segment === '$NavigationPropertyBinding') {
                    const navigationPropertyBindings = thisElement.navigationPropertyBinding;
                    current.target = navigationPropertyBindings;
                    return current;
                }
                // continue resolving at the EntitySet's or Singleton's type
                const result = resolveTarget(converter, thisElement.entityType, segment);
                current.target = result.target;
                current.objectPath = result.objectPath.reduce(appendObjectPath, current.objectPath);
                return current;
            }
            case 'EntityType':
                {
                    const thisElement = current.target;
                    if (segment === '' || segment === '$Type') {
                        return current;
                    }
                    const property = thisElement.entityProperties.by_name(segment);
                    if (property) {
                        current.target = property;
                        return current;
                    }
                    const navigationProperty = thisElement.navigationProperties.by_name(segment);
                    if (navigationProperty) {
                        current.target = navigationProperty;
                        return current;
                    }
                    const action = thisElement.actions[segment];
                    if (action) {
                        current.target = action;
                        return current;
                    }
                }
                break;
            case 'ActionImport': {
                // continue resolving at the Action
                const result = resolveTarget(converter, current.target.action, segment);
                current.target = result.target;
                current.objectPath = result.objectPath.reduce(appendObjectPath, current.objectPath);
                return current;
            }
            case 'Action': {
                const thisElement = current.target;
                if (segment === '') {
                    return current;
                }
                if (segment === '@$ui5.overload' || segment === '0') {
                    return current;
                }
                if (segment === '$Parameter' && thisElement.isBound) {
                    current.target = thisElement.parameters;
                    return current;
                }
                const nextElement = (_e = thisElement.parameters[segment]) !== null && _e !== void 0 ? _e : thisElement.parameters.find((param) => param.name === segment);
                if (nextElement) {
                    current.target = nextElement;
                    return current;
                }
                break;
            }
            case 'Property':
                {
                    const thisElement = current.target;
                    // Property or NavigationProperty of the ComplexType
                    const type = thisElement.targetType;
                    if (type !== undefined) {
                        const property = type.properties.by_name(segment);
                        if (property) {
                            current.target = property;
                            return current;
                        }
                        const navigationProperty = type.navigationProperties.by_name(segment);
                        if (navigationProperty) {
                            current.target = navigationProperty;
                            return current;
                        }
                    }
                }
                break;
            case 'ActionParameter':
                const referencedType = current.target.typeReference;
                if (referencedType !== undefined) {
                    const result = resolveTarget(converter, referencedType, segment);
                    current.target = result.target;
                    current.objectPath = result.objectPath.reduce(appendObjectPath, current.objectPath);
                    return current;
                }
                break;
            case 'NavigationProperty':
                // continue at the NavigationProperty's target type
                const result = resolveTarget(converter, current.target.targetType, segment);
                current.target = result.target;
                current.objectPath = result.objectPath.reduce(appendObjectPath, current.objectPath);
                return current;
            default:
                if (segment === '') {
                    return current;
                }
                if (current.target[segment]) {
                    current.target = current.target[segment];
                    current.objectPath = appendObjectPath(current.objectPath, current.target);
                    return current;
                }
        }
        return error(`Element '${segment}' not found at ${current.target._type} '${current.target.fullyQualifiedName}'`);
    }, { target: startElement, objectPath: [], messages: [] });
    // Diagnostics
    result.messages.forEach((message) => converter.logError(message.message));
    if (!result.target) {
        if (annotationsTerm) {
            const annotationType = inferTypeFromTerm(converter, annotationsTerm, startElement.fullyQualifiedName);
            converter.logError('Unable to resolve the path expression: ' +
                '\n' +
                path +
                '\n' +
                '\n' +
                'Hint: Check and correct the path values under the following structure in the metadata (annotation.xml file or CDS annotations for the application): \n\n' +
                '<Annotation Term = ' +
                annotationsTerm +
                '>' +
                '\n' +
                '<Record Type = ' +
                annotationType +
                '>' +
                '\n' +
                '<AnnotationPath = ' +
                path +
                '>');
        }
        else {
            converter.logError('Unable to resolve the path expression: ' +
                path +
                '\n' +
                '\n' +
                'Hint: Check and correct the path values under the following structure in the metadata (annotation.xml file or CDS annotations for the application): \n\n' +
                '<Annotation Term = ' +
                pathSegments[0] +
                '>' +
                '\n' +
                '<PropertyValue  Path= ' +
                pathSegments[1] +
                '>');
        }
    }
    return result;
}
/**
 * Typeguard to check if the path contains an annotation.
 *
 * @param pathStr the path to evaluate
 * @returns true if there is an annotation in the path.
 */
function isAnnotationPath(pathStr) {
    return pathStr.includes('@');
}
function parseValue(converter, currentTarget, currentTerm, currentProperty, currentSource, propertyValue, valueFQN) {
    if (propertyValue === undefined) {
        return undefined;
    }
    switch (propertyValue.type) {
        case 'String':
            return propertyValue.String;
        case 'Int':
            return propertyValue.Int;
        case 'Bool':
            return propertyValue.Bool;
        case 'Decimal':
            return (0, utils_1.Decimal)(propertyValue.Decimal);
        case 'Date':
            return propertyValue.Date;
        case 'EnumMember':
            const aliasedEnum = converter.alias(propertyValue.EnumMember);
            const splitEnum = aliasedEnum.split(' ');
            if (splitEnum[0] && utils_1.EnumIsFlag[(0, utils_1.substringBeforeFirst)(splitEnum[0], '/')]) {
                return splitEnum;
            }
            return aliasedEnum;
        case 'PropertyPath':
            return {
                type: 'PropertyPath',
                value: propertyValue.PropertyPath,
                fullyQualifiedName: valueFQN,
                $target: resolveTarget(converter, currentTarget, propertyValue.PropertyPath, currentTerm).target,
                [ANNOTATION_TARGET]: currentTarget
            };
        case 'NavigationPropertyPath':
            return {
                type: 'NavigationPropertyPath',
                value: propertyValue.NavigationPropertyPath,
                fullyQualifiedName: valueFQN,
                $target: resolveTarget(converter, currentTarget, propertyValue.NavigationPropertyPath, currentTerm)
                    .target,
                [ANNOTATION_TARGET]: currentTarget
            };
        case 'AnnotationPath':
            return {
                type: 'AnnotationPath',
                value: propertyValue.AnnotationPath,
                fullyQualifiedName: valueFQN,
                $target: resolveTarget(converter, currentTarget, converter.unalias(propertyValue.AnnotationPath), currentTerm).target,
                annotationsTerm: currentTerm,
                term: '',
                path: '',
                [ANNOTATION_TARGET]: currentTarget
            };
        case 'Path':
            const $target = resolveTarget(converter, currentTarget, propertyValue.Path, currentTerm).target;
            if (isAnnotationPath(propertyValue.Path)) {
                // inline the target
                return $target;
            }
            else {
                return {
                    type: 'Path',
                    path: propertyValue.Path,
                    fullyQualifiedName: valueFQN,
                    $target: $target,
                    [ANNOTATION_TARGET]: currentTarget
                };
            }
        case 'Record':
            return parseRecord(converter, currentTerm, currentTarget, currentProperty, currentSource, propertyValue.Record, valueFQN);
        case 'Collection':
            return parseCollection(converter, currentTarget, currentTerm, currentProperty, currentSource, propertyValue.Collection, valueFQN);
        case 'Apply':
        case 'Null':
        case 'Not':
        case 'Eq':
        case 'Ne':
        case 'Gt':
        case 'Ge':
        case 'Lt':
        case 'Le':
        case 'If':
        case 'And':
        case 'Or':
        default:
            return propertyValue;
    }
}
/**
 * Infer the type of a term based on its type.
 *
 * @param converter         Converter
 * @param annotationsTerm   The annotation term
 * @param annotationTarget  The annotation target
 * @param currentProperty   The current property of the record
 * @returns The inferred type.
 */
function inferTypeFromTerm(converter, annotationsTerm, annotationTarget, currentProperty) {
    let targetType = utils_1.TermToTypes[annotationsTerm];
    if (currentProperty) {
        annotationsTerm = `${(0, utils_1.substringBeforeLast)(annotationsTerm, '.')}.${currentProperty}`;
        targetType = utils_1.TermToTypes[annotationsTerm];
    }
    converter.logError(`The type of the record used within the term ${annotationsTerm} was not defined and was inferred as ${targetType}.
Hint: If possible, try to maintain the Type property for each Record.
<Annotations Target="${annotationTarget}">
	<Annotation Term="${annotationsTerm}">
		<Record>...</Record>
	</Annotation>
</Annotations>`);
    return targetType;
}
function isDataFieldWithForAction(annotationContent) {
    return (annotationContent.hasOwnProperty('Action') &&
        (annotationContent.$Type === 'com.sap.vocabularies.UI.v1.DataFieldForAction' ||
            annotationContent.$Type === 'com.sap.vocabularies.UI.v1.DataFieldWithAction'));
}
function parseRecordType(converter, currentTerm, currentTarget, currentProperty, recordDefinition) {
    let targetType;
    if (!recordDefinition.type && currentTerm) {
        targetType = inferTypeFromTerm(converter, currentTerm, currentTarget.fullyQualifiedName, currentProperty);
    }
    else {
        targetType = converter.unalias(recordDefinition.type);
    }
    return targetType;
}
function parseRecord(converter, currentTerm, currentTarget, currentProperty, currentSource, annotationRecord, currentFQN) {
    var _a;
    const annotationTerm = {
        $Type: parseRecordType(converter, currentTerm, currentTarget, currentProperty, annotationRecord),
        fullyQualifiedName: currentFQN,
        [ANNOTATION_TARGET]: currentTarget
    };
    // annotations on the record
    (0, utils_1.lazy)(annotationTerm, 'annotations', () => {
        var _a;
        // be graceful when resolving annotations on annotations: Sometimes they are referenced directly, sometimes they
        // are part of the global annotations list
        let annotations;
        if (annotationRecord.annotations && annotationRecord.annotations.length > 0) {
            annotations = annotationRecord.annotations;
        }
        else {
            annotations = (_a = converter.rawAnnotationsPerTarget[currentFQN]) === null || _a === void 0 ? void 0 : _a.annotations;
        }
        annotations === null || annotations === void 0 ? void 0 : annotations.forEach((annotation) => {
            annotation.target = currentFQN;
            annotation.__source = currentSource;
            annotation[ANNOTATION_TARGET] = currentTarget;
            annotation.fullyQualifiedName = `${currentFQN}@${annotation.term}`;
        });
        return createAnnotationsObject(converter, annotationTerm, annotations !== null && annotations !== void 0 ? annotations : []);
    });
    const annotationContent = (_a = annotationRecord.propertyValues) === null || _a === void 0 ? void 0 : _a.reduce((annotationContent, propertyValue) => {
        (0, utils_1.lazy)(annotationContent, propertyValue.name, () => parseValue(converter, currentTarget, currentTerm, propertyValue.name, currentSource, propertyValue.value, `${currentFQN}/${propertyValue.name}`));
        return annotationContent;
    }, annotationTerm);
    if (isDataFieldWithForAction(annotationContent)) {
        (0, utils_1.lazy)(annotationContent, 'ActionTarget', () => {
            var _a, _b;
            // try to resolve to a bound action of the annotation target
            let actionTarget = (_a = currentTarget.actions) === null || _a === void 0 ? void 0 : _a[annotationContent.Action];
            if (!actionTarget) {
                // try to find a corresponding unbound action
                actionTarget = (_b = converter.getConvertedActionImport(annotationContent.Action)) === null || _b === void 0 ? void 0 : _b.action;
            }
            if (!actionTarget) {
                // try to find a corresponding bound (!) action
                actionTarget = converter.getConvertedAction(annotationContent.Action);
                if (!(actionTarget === null || actionTarget === void 0 ? void 0 : actionTarget.isBound)) {
                    actionTarget = undefined;
                }
            }
            if (!actionTarget) {
                converter.logError(`Unable to resolve the action '${annotationContent.Action}' defined for '${annotationTerm.fullyQualifiedName}'`);
            }
            return actionTarget;
        });
    }
    return annotationContent;
}
/**
 * Retrieve or infer the collection type based on its content.
 *
 * @param collectionDefinition
 * @returns the type of the collection
 */
function getOrInferCollectionType(collectionDefinition) {
    let type = collectionDefinition.type;
    if (type === undefined && collectionDefinition.length > 0) {
        const firstColItem = collectionDefinition[0];
        if (firstColItem.hasOwnProperty('PropertyPath')) {
            type = 'PropertyPath';
        }
        else if (firstColItem.hasOwnProperty('Path')) {
            type = 'Path';
        }
        else if (firstColItem.hasOwnProperty('AnnotationPath')) {
            type = 'AnnotationPath';
        }
        else if (firstColItem.hasOwnProperty('NavigationPropertyPath')) {
            type = 'NavigationPropertyPath';
        }
        else if (typeof firstColItem === 'object' &&
            (firstColItem.hasOwnProperty('type') || firstColItem.hasOwnProperty('propertyValues'))) {
            type = 'Record';
        }
        else if (typeof firstColItem === 'string') {
            type = 'String';
        }
    }
    else if (type === undefined) {
        type = 'EmptyCollection';
    }
    return type;
}
function parseCollection(converter, currentTarget, currentTerm, currentProperty, currentSource, collectionDefinition, parentFQN) {
    const collectionDefinitionType = getOrInferCollectionType(collectionDefinition);
    switch (collectionDefinitionType) {
        case 'PropertyPath':
            return collectionDefinition.map((propertyPath, propertyIdx) => {
                const result = {
                    type: 'PropertyPath',
                    value: propertyPath.PropertyPath,
                    fullyQualifiedName: `${parentFQN}/${propertyIdx}`
                };
                (0, utils_1.lazy)(result, '$target', () => {
                    var _a;
                    return (_a = resolveTarget(converter, currentTarget, propertyPath.PropertyPath, currentTerm)
                        .target) !== null && _a !== void 0 ? _a : {};
                } // TODO: $target is mandatory - throw an error?
                );
                return result;
            });
        case 'Path':
            // TODO: make lazy?
            return collectionDefinition.map((pathValue) => {
                return resolveTarget(converter, currentTarget, pathValue.Path, currentTerm).target;
            });
        case 'AnnotationPath':
            return collectionDefinition.map((annotationPath, annotationIdx) => {
                const result = {
                    type: 'AnnotationPath',
                    value: annotationPath.AnnotationPath,
                    fullyQualifiedName: `${parentFQN}/${annotationIdx}`,
                    annotationsTerm: currentTerm,
                    term: '',
                    path: ''
                };
                (0, utils_1.lazy)(result, '$target', () => resolveTarget(converter, currentTarget, annotationPath.AnnotationPath, currentTerm).target);
                return result;
            });
        case 'NavigationPropertyPath':
            return collectionDefinition.map((navPropertyPath, navPropIdx) => {
                const result = {
                    type: 'NavigationPropertyPath',
                    value: navPropertyPath.NavigationPropertyPath,
                    fullyQualifiedName: `${parentFQN}/${navPropIdx}`
                };
                (0, utils_1.lazy)(result, '$target', () => resolveTarget(converter, currentTarget, navPropertyPath.NavigationPropertyPath, currentTerm)
                    .target);
                return result;
            });
        case 'Record':
            return collectionDefinition.map((recordDefinition, recordIdx) => {
                return parseRecord(converter, currentTerm, currentTarget, currentProperty, currentSource, recordDefinition, `${parentFQN}/${recordIdx}`);
            });
        case 'Apply':
        case 'Null':
        case 'If':
        case 'Eq':
        case 'Ne':
        case 'Lt':
        case 'Gt':
        case 'Le':
        case 'Ge':
        case 'Not':
        case 'And':
        case 'Or':
            return collectionDefinition.map((ifValue) => ifValue);
        case 'String':
            return collectionDefinition.map((stringValue) => {
                if (typeof stringValue === 'string' || stringValue === undefined) {
                    return stringValue;
                }
                else {
                    return stringValue.String;
                }
            });
        default:
            if (collectionDefinition.length === 0) {
                return [];
            }
            throw new Error('Unsupported case');
    }
}
function isV4NavigationProperty(navProp) {
    return !!navProp.targetTypeName;
}
/**
 * Split the alias from the term value.
 *
 * @param references the current set of references
 * @param termValue the value of the term
 * @returns the term alias and the actual term value
 */
function splitTerm(references, termValue) {
    return (0, utils_1.splitAtLast)((0, utils_1.alias)(references, termValue), '.');
}
function convertAnnotation(converter, target, rawAnnotation) {
    var _a;
    let annotation;
    if (rawAnnotation.record) {
        annotation = parseRecord(converter, rawAnnotation.term, target, '', rawAnnotation.__source, rawAnnotation.record, rawAnnotation.fullyQualifiedName);
    }
    else if (rawAnnotation.collection === undefined) {
        annotation = parseValue(converter, target, rawAnnotation.term, '', rawAnnotation.__source, (_a = rawAnnotation.value) !== null && _a !== void 0 ? _a : { type: 'Bool', Bool: true }, rawAnnotation.fullyQualifiedName);
    }
    else if (rawAnnotation.collection) {
        annotation = parseCollection(converter, target, rawAnnotation.term, '', rawAnnotation.__source, rawAnnotation.collection, rawAnnotation.fullyQualifiedName);
    }
    else {
        throw new Error('Unsupported case');
    }
    switch (typeof annotation) {
        case 'string':
            // eslint-disable-next-line no-new-wrappers
            annotation = new String(annotation);
            break;
        case 'boolean':
            // eslint-disable-next-line no-new-wrappers
            annotation = new Boolean(annotation);
            break;
        case 'number':
            annotation = new Number(annotation);
            break;
        default:
            // do nothing
            break;
    }
    annotation.fullyQualifiedName = rawAnnotation.fullyQualifiedName;
    annotation[ANNOTATION_TARGET] = target;
    const [vocAlias, vocTerm] = converter.splitTerm(rawAnnotation.term);
    annotation.term = converter.unalias(`${vocAlias}.${vocTerm}`);
    annotation.qualifier = rawAnnotation.qualifier;
    annotation.__source = rawAnnotation.__source;
    try {
        (0, utils_1.lazy)(annotation, 'annotations', () => {
            var _a;
            const annotationFQN = annotation.fullyQualifiedName;
            // be graceful when resolving annotations on annotations: Sometimes they are referenced directly, sometimes they
            // are part of the global annotations list
            let annotations;
            if (rawAnnotation.annotations && rawAnnotation.annotations.length > 0) {
                annotations = rawAnnotation.annotations;
            }
            else {
                annotations = (_a = converter.rawAnnotationsPerTarget[annotationFQN]) === null || _a === void 0 ? void 0 : _a.annotations;
            }
            annotations === null || annotations === void 0 ? void 0 : annotations.forEach((rawSubAnnotation) => {
                rawSubAnnotation.target = annotationFQN;
                rawSubAnnotation.__source = annotation.__source;
                rawSubAnnotation[ANNOTATION_TARGET] = target;
                rawSubAnnotation.fullyQualifiedName = `${annotationFQN}@${rawSubAnnotation.term}`;
            });
            return createAnnotationsObject(converter, annotation, annotations !== null && annotations !== void 0 ? annotations : []);
        });
    }
    catch (e) {
        // not an error: parseRecord() already adds annotations, but the other parseXXX functions don't, so this can happen
    }
    return annotation;
}
function getAnnotationFQN(currentTargetName, references, annotation) {
    const annotationFQN = `${currentTargetName}@${(0, utils_1.unalias)(references, annotation.term)}`;
    if (annotation.qualifier) {
        return `${annotationFQN}#${annotation.qualifier}`;
    }
    else {
        return annotationFQN;
    }
}
/**
 * Merge annotation from different source together by overwriting at the term level.
 *
 * @param rawMetadata
 * @returns the resulting merged annotations
 */
function mergeAnnotations(rawMetadata) {
    const annotationListPerTarget = {};
    Object.keys(rawMetadata.schema.annotations).forEach((annotationSource) => {
        rawMetadata.schema.annotations[annotationSource].forEach((annotationList) => {
            const currentTargetName = (0, utils_1.unalias)(rawMetadata.references, annotationList.target);
            annotationList.__source = annotationSource;
            if (!annotationListPerTarget[currentTargetName]) {
                annotationListPerTarget[currentTargetName] = {
                    annotations: annotationList.annotations.map((annotation) => {
                        annotation.fullyQualifiedName = getAnnotationFQN(currentTargetName, rawMetadata.references, annotation);
                        annotation.__source = annotationSource;
                        return annotation;
                    }),
                    target: currentTargetName
                };
                annotationListPerTarget[currentTargetName].__source = annotationSource;
            }
            else {
                annotationList.annotations.forEach((annotation) => {
                    const findIndex = annotationListPerTarget[currentTargetName].annotations.findIndex((referenceAnnotation) => {
                        return (referenceAnnotation.term === annotation.term &&
                            referenceAnnotation.qualifier === annotation.qualifier);
                    });
                    annotation.__source = annotationSource;
                    annotation.fullyQualifiedName = getAnnotationFQN(currentTargetName, rawMetadata.references, annotation);
                    if (findIndex !== -1) {
                        annotationListPerTarget[currentTargetName].annotations.splice(findIndex, 1, annotation);
                    }
                    else {
                        annotationListPerTarget[currentTargetName].annotations.push(annotation);
                    }
                });
            }
        });
    });
    return annotationListPerTarget;
}
class Converter {
    get rawAnnotationsPerTarget() {
        if (this._rawAnnotationsPerTarget === undefined) {
            this._rawAnnotationsPerTarget = mergeAnnotations(this.rawMetadata);
        }
        return this._rawAnnotationsPerTarget;
    }
    getConvertedEntityContainer() {
        return this.getConvertedElement(this.rawMetadata.schema.entityContainer.fullyQualifiedName, this.rawMetadata.schema.entityContainer, convertEntityContainer);
    }
    getConvertedEntitySet(fullyQualifiedName) {
        return this.convertedOutput.entitySets.by_fullyQualifiedName(fullyQualifiedName);
    }
    getConvertedSingleton(fullyQualifiedName) {
        return this.convertedOutput.singletons.by_fullyQualifiedName(fullyQualifiedName);
    }
    getConvertedEntityType(fullyQualifiedName) {
        return this.convertedOutput.entityTypes.by_fullyQualifiedName(fullyQualifiedName);
    }
    getConvertedComplexType(fullyQualifiedName) {
        return this.convertedOutput.complexTypes.by_fullyQualifiedName(fullyQualifiedName);
    }
    getConvertedTypeDefinition(fullyQualifiedName) {
        return this.convertedOutput.typeDefinitions.by_fullyQualifiedName(fullyQualifiedName);
    }
    getConvertedActionImport(fullyQualifiedName) {
        let actionImport = this.convertedOutput.actionImports.by_fullyQualifiedName(fullyQualifiedName);
        if (!actionImport) {
            actionImport = this.convertedOutput.actionImports.by_name(fullyQualifiedName);
        }
        return actionImport;
    }
    getConvertedAction(fullyQualifiedName) {
        return this.convertedOutput.actions.by_fullyQualifiedName(fullyQualifiedName);
    }
    convert(rawValue, map) {
        if (Array.isArray(rawValue)) {
            return () => {
                const converted = rawValue.reduce((convertedElements, rawElement) => {
                    const convertedElement = this.getConvertedElement(rawElement.fullyQualifiedName, rawElement, map);
                    if (convertedElement) {
                        convertedElements.push(convertedElement);
                    }
                    return convertedElements;
                }, []);
                (0, utils_1.addGetByValue)(converted, 'name');
                (0, utils_1.addGetByValue)(converted, 'fullyQualifiedName');
                return converted;
            };
        }
        else {
            return () => this.getConvertedElement(rawValue.fullyQualifiedName, rawValue, map);
        }
    }
    constructor(rawMetadata, convertedOutput) {
        this.convertedElements = new Map();
        this.rawMetadata = rawMetadata;
        this.rawSchema = rawMetadata.schema;
        this.convertedOutput = convertedOutput;
    }
    getConvertedElement(fullyQualifiedName, rawElement, map) {
        let converted = this.convertedElements.get(fullyQualifiedName);
        if (converted === undefined) {
            const rawMetadata = typeof rawElement === 'function' ? rawElement.apply(undefined, [fullyQualifiedName]) : rawElement;
            if (rawMetadata !== undefined) {
                converted = map.apply(undefined, [this, rawMetadata]);
                this.convertedElements.set(fullyQualifiedName, converted);
            }
        }
        return converted;
    }
    logError(message) {
        this.convertedOutput.diagnostics.push({ message });
    }
    splitTerm(term) {
        return splitTerm(this.rawMetadata.references, term);
    }
    alias(value) {
        return (0, utils_1.alias)(this.rawMetadata.references, value);
    }
    unalias(value) {
        var _a;
        return (_a = (0, utils_1.unalias)(this.rawMetadata.references, value)) !== null && _a !== void 0 ? _a : '';
    }
}
function resolveEntityType(converter, fullyQualifiedName) {
    return () => {
        let entityType = converter.getConvertedEntityType(fullyQualifiedName);
        if (!entityType) {
            converter.logError(`EntityType '${fullyQualifiedName}' not found`);
            entityType = {};
        }
        return entityType;
    };
}
function resolveNavigationPropertyBindings(converter, rawNavigationPropertyBindings, rawElement) {
    return () => Object.keys(rawNavigationPropertyBindings).reduce((navigationPropertyBindings, bindingName) => {
        const rawBindingTarget = rawNavigationPropertyBindings[bindingName];
        (0, utils_1.lazy)(navigationPropertyBindings, bindingName, () => {
            let resolvedBindingTarget;
            if (rawBindingTarget._type === 'Singleton') {
                resolvedBindingTarget = converter.getConvertedSingleton(rawBindingTarget.fullyQualifiedName);
            }
            else {
                resolvedBindingTarget = converter.getConvertedEntitySet(rawBindingTarget.fullyQualifiedName);
            }
            if (!resolvedBindingTarget) {
                converter.logError(`${rawElement._type} '${rawElement.fullyQualifiedName}': Failed to resolve NavigationPropertyBinding ${bindingName}`);
                resolvedBindingTarget = {};
            }
            return resolvedBindingTarget;
        });
        return navigationPropertyBindings;
    }, {});
}
function resolveAnnotations(converter, rawAnnotationTarget) {
    const nestedAnnotations = rawAnnotationTarget.annotations;
    return () => {
        var _a, _b;
        return createAnnotationsObject(converter, rawAnnotationTarget, (_b = nestedAnnotations !== null && nestedAnnotations !== void 0 ? nestedAnnotations : (_a = converter.rawAnnotationsPerTarget[rawAnnotationTarget.fullyQualifiedName]) === null || _a === void 0 ? void 0 : _a.annotations) !== null && _b !== void 0 ? _b : []);
    };
}
function createAnnotationsObject(converter, target, rawAnnotations) {
    return rawAnnotations.reduce((vocabularyAliases, annotation) => {
        const [vocAlias, vocTerm] = converter.splitTerm(annotation.term);
        const vocTermWithQualifier = `${vocTerm}${annotation.qualifier ? '#' + annotation.qualifier : ''}`;
        if (vocabularyAliases[vocAlias] === undefined) {
            vocabularyAliases[vocAlias] = {};
        }
        if (!vocabularyAliases[vocAlias].hasOwnProperty(vocTermWithQualifier)) {
            (0, utils_1.lazy)(vocabularyAliases[vocAlias], vocTermWithQualifier, () => converter.getConvertedElement(annotation.fullyQualifiedName, annotation, (converter, rawAnnotation) => convertAnnotation(converter, target, rawAnnotation)));
        }
        return vocabularyAliases;
    }, {});
}
/**
 * Converts an EntityContainer.
 *
 * @param converter     Converter
 * @param rawEntityContainer    Unconverted EntityContainer
 * @returns The converted EntityContainer
 */
function convertEntityContainer(converter, rawEntityContainer) {
    const convertedEntityContainer = rawEntityContainer;
    (0, utils_1.lazy)(convertedEntityContainer, 'annotations', resolveAnnotations(converter, rawEntityContainer));
    (0, utils_1.lazy)(convertedEntityContainer, 'entitySets', converter.convert(converter.rawSchema.entitySets, convertEntitySet));
    (0, utils_1.lazy)(convertedEntityContainer, 'singletons', converter.convert(converter.rawSchema.singletons, convertSingleton));
    (0, utils_1.lazy)(convertedEntityContainer, 'actionImports', converter.convert(converter.rawSchema.actionImports, convertActionImport));
    return convertedEntityContainer;
}
/**
 * Converts a Singleton.
 *
 * @param converter   Converter
 * @param rawSingleton  Unconverted Singleton
 * @returns The converted Singleton
 */
function convertSingleton(converter, rawSingleton) {
    const convertedSingleton = rawSingleton;
    convertedSingleton.entityTypeName = converter.unalias(rawSingleton.entityTypeName);
    (0, utils_1.lazy)(convertedSingleton, 'entityType', resolveEntityType(converter, rawSingleton.entityTypeName));
    (0, utils_1.lazy)(convertedSingleton, 'annotations', resolveAnnotations(converter, rawSingleton));
    const _rawNavigationPropertyBindings = rawSingleton.navigationPropertyBinding;
    (0, utils_1.lazy)(convertedSingleton, 'navigationPropertyBinding', resolveNavigationPropertyBindings(converter, _rawNavigationPropertyBindings, rawSingleton));
    return convertedSingleton;
}
/**
 * Converts an EntitySet.
 *
 * @param converter   Converter
 * @param rawEntitySet  Unconverted EntitySet
 * @returns The converted EntitySet
 */
function convertEntitySet(converter, rawEntitySet) {
    const convertedEntitySet = rawEntitySet;
    convertedEntitySet.entityTypeName = converter.unalias(rawEntitySet.entityTypeName);
    (0, utils_1.lazy)(convertedEntitySet, 'entityType', resolveEntityType(converter, rawEntitySet.entityTypeName));
    (0, utils_1.lazy)(convertedEntitySet, 'annotations', resolveAnnotations(converter, rawEntitySet));
    const _rawNavigationPropertyBindings = rawEntitySet.navigationPropertyBinding;
    (0, utils_1.lazy)(convertedEntitySet, 'navigationPropertyBinding', resolveNavigationPropertyBindings(converter, _rawNavigationPropertyBindings, rawEntitySet));
    return convertedEntitySet;
}
/**
 * Converts an EntityType.
 *
 * @param converter   Converter
 * @param rawEntityType  Unconverted EntityType
 * @returns The converted EntityType
 */
function convertEntityType(converter, rawEntityType) {
    const convertedEntityType = rawEntityType;
    rawEntityType.keys.forEach((keyProp) => {
        keyProp.isKey = true;
    });
    (0, utils_1.lazy)(convertedEntityType, 'annotations', resolveAnnotations(converter, rawEntityType));
    (0, utils_1.lazy)(convertedEntityType, 'keys', converter.convert(rawEntityType.keys, convertProperty));
    (0, utils_1.lazy)(convertedEntityType, 'entityProperties', converter.convert(rawEntityType.entityProperties, convertProperty));
    (0, utils_1.lazy)(convertedEntityType, 'navigationProperties', converter.convert(rawEntityType.navigationProperties, convertNavigationProperty));
    (0, utils_1.lazy)(convertedEntityType, 'actions', () => converter.rawSchema.actions
        .filter((rawAction) => rawAction.isBound &&
        (rawAction.sourceType === rawEntityType.fullyQualifiedName ||
            rawAction.sourceType === `Collection(${rawEntityType.fullyQualifiedName})`))
        .reduce((actions, rawAction) => {
        const name = `${converter.rawSchema.namespace}.${rawAction.name}`;
        actions[name] = converter.getConvertedAction(rawAction.fullyQualifiedName);
        return actions;
    }, {}));
    convertedEntityType.resolvePath = (relativePath, includeVisitedObjects) => {
        const resolved = resolveTarget(converter, rawEntityType, relativePath);
        if (includeVisitedObjects) {
            return { target: resolved.target, visitedObjects: resolved.objectPath, messages: resolved.messages };
        }
        else {
            return resolved.target;
        }
    };
    return convertedEntityType;
}
/**
 * Converts a Property.
 *
 * @param converter   Converter
 * @param rawProperty  Unconverted Property
 * @returns The converted Property
 */
function convertProperty(converter, rawProperty) {
    const convertedProperty = rawProperty;
    convertedProperty.type = converter.unalias(rawProperty.type);
    (0, utils_1.lazy)(convertedProperty, 'annotations', resolveAnnotations(converter, rawProperty));
    (0, utils_1.lazy)(convertedProperty, 'targetType', () => {
        var _a;
        const type = rawProperty.type;
        const typeName = type.startsWith('Collection') ? type.substring(11, type.length - 1) : type;
        return (_a = converter.getConvertedComplexType(typeName)) !== null && _a !== void 0 ? _a : converter.getConvertedTypeDefinition(typeName);
    });
    return convertedProperty;
}
/**
 * Converts a NavigationProperty.
 *
 * @param converter   Converter
 * @param rawNavigationProperty  Unconverted NavigationProperty
 * @returns The converted NavigationProperty
 */
function convertNavigationProperty(converter, rawNavigationProperty) {
    var _a, _b, _c;
    const convertedNavigationProperty = rawNavigationProperty;
    convertedNavigationProperty.referentialConstraint = (_a = convertedNavigationProperty.referentialConstraint) !== null && _a !== void 0 ? _a : [];
    if (isV4NavigationProperty(rawNavigationProperty)) {
        convertedNavigationProperty.targetTypeName = converter.unalias(rawNavigationProperty.targetTypeName);
    }
    else {
        const associationEnd = (_b = converter.rawSchema.associations
            .find((association) => association.fullyQualifiedName === rawNavigationProperty.relationship)) === null || _b === void 0 ? void 0 : _b.associationEnd.find((end) => end.role === rawNavigationProperty.toRole);
        convertedNavigationProperty.isCollection = (associationEnd === null || associationEnd === void 0 ? void 0 : associationEnd.multiplicity) === '*';
        convertedNavigationProperty.targetTypeName = (_c = associationEnd === null || associationEnd === void 0 ? void 0 : associationEnd.type) !== null && _c !== void 0 ? _c : '';
    }
    (0, utils_1.lazy)(convertedNavigationProperty, 'targetType', resolveEntityType(converter, rawNavigationProperty.targetTypeName));
    (0, utils_1.lazy)(convertedNavigationProperty, 'annotations', resolveAnnotations(converter, rawNavigationProperty));
    return convertedNavigationProperty;
}
/**
 * Converts an ActionImport.
 *
 * @param converter   Converter
 * @param rawActionImport  Unconverted ActionImport
 * @returns The converted ActionImport
 */
function convertActionImport(converter, rawActionImport) {
    const convertedActionImport = rawActionImport;
    convertedActionImport.actionName = converter.unalias(rawActionImport.actionName);
    (0, utils_1.lazy)(convertedActionImport, 'annotations', resolveAnnotations(converter, rawActionImport));
    (0, utils_1.lazy)(convertedActionImport, 'action', () => converter.getConvertedAction(rawActionImport.actionName));
    return convertedActionImport;
}
/**
 * Converts an Action.
 *
 * @param converter   Converter
 * @param rawAction  Unconverted Action
 * @returns The converted Action
 */
function convertAction(converter, rawAction) {
    const convertedAction = rawAction;
    convertedAction.sourceType = converter.unalias(rawAction.sourceType);
    if (convertedAction.sourceType) {
        (0, utils_1.lazy)(convertedAction, 'sourceEntityType', resolveEntityType(converter, rawAction.sourceType));
    }
    convertedAction.returnType = converter.unalias(rawAction.returnType);
    if (convertedAction.returnType) {
        (0, utils_1.lazy)(convertedAction, 'returnEntityType', resolveEntityType(converter, rawAction.returnType));
    }
    (0, utils_1.lazy)(convertedAction, 'parameters', converter.convert(rawAction.parameters, convertActionParameter));
    (0, utils_1.lazy)(convertedAction, 'annotations', () => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        // this.is.the.action(on.this.type) --> action: 'this.is.the.action', overload: 'on.this.type'
        // this.is.the.action()             --> action: 'this.is.the.action', overload: undefined
        // this.is.the.action               --> action: 'this.is.the.action', overload: undefined
        const actionAndOverload = rawAction.fullyQualifiedName.match(/(?<action>[^()]+)(?:\((?<overload>.*)\))?/);
        let rawAnnotations = [];
        if (actionAndOverload) {
            if ((_a = actionAndOverload.groups) === null || _a === void 0 ? void 0 : _a.overload) {
                rawAnnotations = (_c = (_b = converter.rawAnnotationsPerTarget[rawAction.fullyQualifiedName]) === null || _b === void 0 ? void 0 : _b.annotations) !== null && _c !== void 0 ? _c : [];
            }
            else {
                rawAnnotations =
                    (_f = (_e = converter.rawAnnotationsPerTarget[`${(_d = actionAndOverload.groups) === null || _d === void 0 ? void 0 : _d.action}()`]) === null || _e === void 0 ? void 0 : _e.annotations) !== null && _f !== void 0 ? _f : [];
            }
            if (((_g = actionAndOverload.groups) === null || _g === void 0 ? void 0 : _g.action) && ((_h = actionAndOverload.groups) === null || _h === void 0 ? void 0 : _h.action) !== rawAction.fullyQualifiedName) {
                const baseAnnotations = (_l = (_k = converter.rawAnnotationsPerTarget[(_j = actionAndOverload.groups) === null || _j === void 0 ? void 0 : _j.action]) === null || _k === void 0 ? void 0 : _k.annotations) !== null && _l !== void 0 ? _l : [];
                rawAnnotations = rawAnnotations.concat(baseAnnotations);
            }
        }
        return createAnnotationsObject(converter, rawAction, rawAnnotations);
    });
    return convertedAction;
}
/**
 * Converts an ActionParameter.
 *
 * @param converter   Converter
 * @param rawActionParameter  Unconverted ActionParameter
 * @returns The converted ActionParameter
 */
function convertActionParameter(converter, rawActionParameter) {
    const convertedActionParameter = rawActionParameter;
    (0, utils_1.lazy)(convertedActionParameter, 'typeReference', () => {
        var _a, _b;
        return (_b = (_a = converter.getConvertedEntityType(rawActionParameter.type)) !== null && _a !== void 0 ? _a : converter.getConvertedComplexType(rawActionParameter.type)) !== null && _b !== void 0 ? _b : converter.getConvertedTypeDefinition(rawActionParameter.type);
    });
    (0, utils_1.lazy)(convertedActionParameter, 'annotations', resolveAnnotations(converter, rawActionParameter));
    return convertedActionParameter;
}
/**
 * Converts a ComplexType.
 *
 * @param converter   Converter
 * @param rawComplexType  Unconverted ComplexType
 * @returns The converted ComplexType
 */
function convertComplexType(converter, rawComplexType) {
    const convertedComplexType = rawComplexType;
    (0, utils_1.lazy)(convertedComplexType, 'properties', converter.convert(rawComplexType.properties, convertProperty));
    (0, utils_1.lazy)(convertedComplexType, 'navigationProperties', converter.convert(rawComplexType.navigationProperties, convertNavigationProperty));
    (0, utils_1.lazy)(convertedComplexType, 'annotations', resolveAnnotations(converter, rawComplexType));
    return convertedComplexType;
}
/**
 * Converts a TypeDefinition.
 *
 * @param converter   Converter
 * @param rawTypeDefinition  Unconverted TypeDefinition
 * @returns The converted TypeDefinition
 */
function convertTypeDefinition(converter, rawTypeDefinition) {
    const convertedTypeDefinition = rawTypeDefinition;
    (0, utils_1.lazy)(convertedTypeDefinition, 'annotations', resolveAnnotations(converter, rawTypeDefinition));
    return convertedTypeDefinition;
}
/**
 * Convert a RawMetadata into an object representation to be used to easily navigate a metadata object and its annotation.
 *
 * @param rawMetadata
 * @returns the converted representation of the metadata.
 */
function convert(rawMetadata) {
    // fall back on the default references if the caller does not specify any
    if (rawMetadata.references.length === 0) {
        rawMetadata.references = utils_1.defaultReferences;
    }
    // Converter Output
    const convertedOutput = {
        version: rawMetadata.version,
        namespace: rawMetadata.schema.namespace,
        annotations: rawMetadata.schema.annotations,
        references: utils_1.defaultReferences.concat(rawMetadata.references),
        diagnostics: []
    };
    // Converter
    const converter = new Converter(rawMetadata, convertedOutput);
    (0, utils_1.lazy)(convertedOutput, 'entityContainer', converter.convert(converter.rawSchema.entityContainer, convertEntityContainer));
    (0, utils_1.lazy)(convertedOutput, 'entitySets', converter.convert(converter.rawSchema.entitySets, convertEntitySet));
    (0, utils_1.lazy)(convertedOutput, 'singletons', converter.convert(converter.rawSchema.singletons, convertSingleton));
    (0, utils_1.lazy)(convertedOutput, 'entityTypes', converter.convert(converter.rawSchema.entityTypes, convertEntityType));
    (0, utils_1.lazy)(convertedOutput, 'actions', converter.convert(converter.rawSchema.actions, convertAction));
    (0, utils_1.lazy)(convertedOutput, 'complexTypes', converter.convert(converter.rawSchema.complexTypes, convertComplexType));
    (0, utils_1.lazy)(convertedOutput, 'actionImports', converter.convert(converter.rawSchema.actionImports, convertActionImport));
    (0, utils_1.lazy)(convertedOutput, 'typeDefinitions', converter.convert(converter.rawSchema.typeDefinitions, convertTypeDefinition));
    convertedOutput.resolvePath = function resolvePath(path) {
        const targetResolution = resolveTarget(converter, undefined, path);
        if (targetResolution.target) {
            appendObjectPath(targetResolution.objectPath, targetResolution.target);
        }
        return targetResolution;
    };
    return convertedOutput;
}
exports.convert = convert;
//# sourceMappingURL=converter.js.map