"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.importProjectSchemaAndConfig = exports.importProjectSchema = exports.getEntityTypeEntitySetFromContextPath = exports.getEntitySetByEntitySetName = void 0;
const ux_specification_types_1 = require("@sap/ux-specification-types");
const generate_1 = require("../v2/generate");
const appProvider_1 = require("../v2/import/app/appProvider");
const ovpProvider_1 = require("../v2/import/app/ovpProvider");
const generate_2 = require("../v4/generate");
const utils_1 = require("../v4/utils/utils");
const app_1 = require("../v4/import/app");
const utils_2 = require("./utils");
const i18next_1 = __importDefault(require("i18next"));
const extensionLogger_1 = require("../../extensionLogger");
const i18n_1 = require("../../i18n/i18n");
const schemaAccess_1 = require("../../specification/schemaAccess");
/**
 * Generates an object comprising all generic schemas
 * @param {TemplateType} templateType - Template type
 * @param {FioriElementsVersion} fioriElementsVersion - Fiori Elements version
 * @returns {Object} genericSchemas
 */
async function getGenericSchemas(templateType, fioriElementsVersion) {
    const genericSchemas = {};
    let schemaTypes = [];
    schemaTypes = [ux_specification_types_1.SchemaType.Application];
    switch (templateType) {
        case ux_specification_types_1.TemplateType.ListReportObjectPageV4:
        case ux_specification_types_1.TemplateType.AnalyticalListPageV4:
            schemaTypes.push(ux_specification_types_1.SchemaType.ListReport, ux_specification_types_1.SchemaType.ObjectPage, ux_specification_types_1.SchemaType.FPMCustomPage);
            break;
        case ux_specification_types_1.TemplateType.FreestylePageV4:
            schemaTypes.push(ux_specification_types_1.SchemaType.ListReport, ux_specification_types_1.SchemaType.ObjectPage, ux_specification_types_1.SchemaType.FreestylePage, ux_specification_types_1.SchemaType.FPMCustomPage);
            break;
        case ux_specification_types_1.TemplateType.ListReportObjectPageV2:
            schemaTypes.push(ux_specification_types_1.SchemaType.ListReport, ux_specification_types_1.SchemaType.ObjectPage);
            break;
        case ux_specification_types_1.TemplateType.AnalyticalListPageV2:
            schemaTypes.push(ux_specification_types_1.SchemaType.AnalyticalListPage, ux_specification_types_1.SchemaType.ObjectPage);
            break;
        case ux_specification_types_1.TemplateType.OverviewPageV2:
            schemaTypes.push(ux_specification_types_1.SchemaType.OverviewPage);
            break;
        default:
            break;
    }
    for (const schemaType of schemaTypes) {
        const schemaFile = utils_2.getSchemaFilePath(schemaType);
        genericSchemas[schemaFile.filename] = await schemaAccess_1.getGenericSchema(fioriElementsVersion, schemaType);
    }
    return genericSchemas;
}
/**
 * Get the relevant UI.ListItem and UI.Facet entity sets
 * @param {ConvertedMetadata} oDataServiceAVT - Annotations as converted by AVT
 * @returns a fitered list of facet and line item annotations
 */
function getAnnotationsForUi(oDataServiceAVT) {
    const filteredEntityTypes = {
        Facets: [],
        LineItems: []
    };
    const allEntityTypes = oDataServiceAVT?.entityTypes;
    if (!allEntityTypes) {
        return filteredEntityTypes;
    }
    const alias = utils_2.findAlias(ux_specification_types_1.UIVOCABULARY, oDataServiceAVT);
    for (const entity of allEntityTypes) {
        if (!entity.annotations || !entity.annotations[alias]) {
            continue;
        }
        const { LineItem, Facets } = entity.annotations[alias];
        if (LineItem &&
            !LineItem.qualifier &&
            LineItem.find((li) => li.$Type === "com.sap.vocabularies.UI.v1.DataField" /* DataField */ || li.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAnnotation" /* DataFieldForAnnotation */)) {
            filteredEntityTypes.LineItems.push(entity.name);
        }
        if (Facets && !Facets.qualifier) {
            filteredEntityTypes.Facets.push(entity.name);
        }
    }
    return filteredEntityTypes;
}
function getEntitySetByEntitySetName(entitySetName, oDataServiceAVT) {
    return oDataServiceAVT?.entitySets && oDataServiceAVT.entitySets.find((es) => es.name === entitySetName);
}
exports.getEntitySetByEntitySetName = getEntitySetByEntitySetName;
/**
 * The function returns an EntityType, EntitySet based on the given contextPath or entitySet
 * @param {ConvertedMetadata} oDataServiceAVT service AVT
 * @param {string} contextPath contextPath of a page
 * @param {string} entitySetName entitySet of a page
 * @param {ExtensionLogger} [logger] - Logger class for logging messages
 *
 * @returns {EntityType} entityType of a page
 */
function getEntityTypeEntitySetFromContextPath(oDataServiceAVT, contextPath, entitySetName, logger) {
    const resolvedContextPath = oDataServiceAVT?.resolvePath(contextPath || `/${entitySetName}`);
    let entityType, entitySet;
    if (resolvedContextPath?.target?.['_type'] === 'EntitySet') {
        entityType = resolvedContextPath['target']?.entityType;
        entitySet = resolvedContextPath?.['target'];
    }
    else if (resolvedContextPath?.target?.['_type'] === 'NavigationProperty') {
        entityType = resolvedContextPath['target']['targetType'];
    }
    if (!resolvedContextPath) {
        extensionLogger_1.log(logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('CONTEXTPATHCOULDNOTBERESOLVED', { entitySet: entitySetName, contextPath }),
            location: {
                path: ux_specification_types_1.METADATAPATH
            }
        });
    }
    return { entityType, entitySet };
}
exports.getEntityTypeEntitySetFromContextPath = getEntityTypeEntitySetFromContextPath;
/**
 * The function generates one app schema per entitySet that is linked with an object page in V2
 * @param {GenerateSchemaParameters} generateParameters - list of API input parameters
 * @param {Schema} genericSchemas - The generic schemas
 * @param {Schema} appSchemas - the list of app schemas that shall get extended
 */
function generateObjectPageSchemasV2(generateParameters, genericSchemas, appSchemas) {
    const allPages = appProvider_1.getPages(generateParameters.manifest[ux_specification_types_1.ManifestSection.generic].pages, ux_specification_types_1.v2.FE_TEMPLATE_V2_OBJECT_PAGE);
    for (const page in allPages) {
        const entitySetName = allPages[page].entitySet;
        const entitySet = getEntitySetByEntitySetName(entitySetName, generateParameters.serviceAVT);
        if (!entitySet) {
            extensionLogger_1.log(generateParameters.logger, {
                severity: "error" /* Error */,
                message: i18next_1.default.t('ENTITYSETNOTFOUND', { entitySetName: entitySetName }),
                location: {
                    path: ux_specification_types_1.METADATAPATH
                }
            });
        }
        generateParameters.entitySet = entitySet;
        const schemaFile = utils_2.getSchemaFilePath(ux_specification_types_1.SchemaType.ObjectPage, entitySet?.name || entitySetName);
        const genericSchemaFile = utils_2.getSchemaFilePath(ux_specification_types_1.SchemaType.ObjectPage);
        appSchemas[schemaFile.filename] = generate_1.generateObjectPageSchemaV2(generateParameters, genericSchemas[genericSchemaFile.filename]);
    }
}
/**
 * The function generates one app schema per entitySet that is linked with a list report/alp page in V4
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param {Schemas} genericSchemas - The generic schemas
 * @param {Schemas} appSchemas - the list of app schemas that shall get extended
 */
function generateListReportSchemasV4(generateParameters, genericSchemas, appSchemas) {
    const lrPages = app_1.getPages(generateParameters.manifest, ux_specification_types_1.v4.FE_TEMPLATE_V4_LIST_REPORT);
    const alpPages = app_1.getPages(generateParameters.manifest, ux_specification_types_1.v4.FE_TEMPLATE_V4_ALP);
    const pages = { ...lrPages, ...alpPages };
    const serviceAVT = generateParameters?.serviceAVT;
    for (const pageId in pages) {
        const entitySetName = pages[pageId].options.settings?.entitySet;
        const contextPath = pages[pageId].options.settings?.contextPath;
        const { entitySet, entityType } = getEntityTypeEntitySetFromContextPath(serviceAVT, contextPath, entitySetName);
        generateParameters.entityType = entityType;
        generateParameters.entitySet = entitySet;
        const schemaFile = utils_2.getSchemaFilePath(ux_specification_types_1.SchemaType.ListReport, pageId);
        const genericSchemaFile = utils_2.getSchemaFilePath(ux_specification_types_1.SchemaType.ListReport);
        // Get ALP/LR template type for existing LR page in freestyle app
        if (generateParameters.templateType === ux_specification_types_1.TemplateType.FreestylePageV4) {
            generateParameters.templateType = utils_2.determineV4PageTemplateType(pages[pageId]);
        }
        appSchemas[schemaFile.filename] = generate_2.generateListReportSchemaV4(generateParameters, genericSchemas[genericSchemaFile.filename], pages[pageId].name, contextPath);
    }
}
/**
 * The function generates one app schema per entitySet that is linked with an object page in V4
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param {Schemas} genericSchemas - The generic schemas
 * @param {Schemas} appSchemas - the list of app schemas that shall get extended
 */
function generateObjectPageSchemasV4(generateParameters, genericSchemas, appSchemas) {
    const pages = app_1.getPages(generateParameters.manifest, ux_specification_types_1.v4.FE_TEMPLATE_V4_OBJECT_PAGE);
    const serviceAVT = generateParameters.serviceAVT;
    for (const page in pages) {
        const entitySetName = pages[page].options.settings?.entitySet;
        const contextPath = pages[page].options.settings?.contextPath;
        const { entityType, entitySet } = getEntityTypeEntitySetFromContextPath(serviceAVT, contextPath, entitySetName);
        generateParameters.entitySet = entitySet;
        generateParameters.entityType = entityType;
        const schemaFile = utils_2.getSchemaFilePath(ux_specification_types_1.SchemaType.ObjectPage, page);
        const genericSchemaFile = utils_2.getSchemaFilePath(ux_specification_types_1.SchemaType.ObjectPage);
        appSchemas[schemaFile.filename] = generate_2.generateObjectPageSchemaV4(generateParameters, genericSchemas[genericSchemaFile.filename], contextPath);
    }
}
/**
 * Generates all app specific schemas for a Fiori Elements V2 application
 * @param {GenerateSchemaParameters} generateParameters - list of API input parameters
 * @param {Schemas} genericSchemas - The generic schemas
 * @param {UiEntityTypes} uiEntityTypes - list of all entity types, as comprised in oDataServiceAVT
 * @param {TemplateType} templateType - the given Fiori Elements' template type
 */
function generateAppSchemasV2(generateParameters, genericSchemas, uiEntityTypes, templateType) {
    const appSchemas = {};
    if (templateType === ux_specification_types_1.TemplateType.ListReportObjectPageV2 && uiEntityTypes) {
        /*--- List Report ----*/
        const allPages = appProvider_1.getPages(generateParameters.manifest[ux_specification_types_1.ManifestSection.generic].pages, ux_specification_types_1.v2.FE_TEMPLATE_V2_LIST_REPORT);
        for (const page in allPages) {
            const entitySetName = allPages[page].entitySet;
            generateParameters.entitySet = getEntitySetByEntitySetName(entitySetName, generateParameters.serviceAVT);
            const schemaFile = utils_2.getSchemaFilePath(ux_specification_types_1.SchemaType.ListReport, generateParameters.entitySet?.name || entitySetName);
            const genericSchemaFile = utils_2.getSchemaFilePath(ux_specification_types_1.SchemaType.ListReport);
            appSchemas[schemaFile.filename] = generate_1.generateListReportSchemaV2(generateParameters, genericSchemas[genericSchemaFile.filename]);
        }
        /*--- Object Pages ----*/
        generateObjectPageSchemasV2(generateParameters, genericSchemas, appSchemas);
    }
    else if (templateType === ux_specification_types_1.TemplateType.AnalyticalListPageV2 && uiEntityTypes) {
        /*--- Analytical List Page ----*/
        const allPages = appProvider_1.getPages(generateParameters.manifest[ux_specification_types_1.ManifestSection.generic].pages, ux_specification_types_1.v2.FE_TEMPLATE_V2_ALP);
        for (const page in allPages) {
            const entitySetName = allPages[page].entitySet;
            generateParameters.entitySet = getEntitySetByEntitySetName(entitySetName, generateParameters.serviceAVT);
            const schemaFile = utils_2.getSchemaFilePath(ux_specification_types_1.SchemaType.AnalyticalListPage, generateParameters.entitySet?.name || entitySetName);
            const genericSchemaFile = utils_2.getSchemaFilePath(ux_specification_types_1.SchemaType.AnalyticalListPage);
            appSchemas[schemaFile.filename] = generate_1.generateAnalyticalListReportSchemaV2(generateParameters, genericSchemas[genericSchemaFile.filename]);
        }
        /*--- Object Pages ----*/
        generateObjectPageSchemasV2(generateParameters, genericSchemas, appSchemas);
    }
    else if (templateType === ux_specification_types_1.TemplateType.OverviewPageV2) {
        /*--- Overview Page ----*/
        const schemaFile = utils_2.getSchemaFilePath(ux_specification_types_1.SchemaType.OverviewPage);
        const genericSchemaFile = utils_2.getSchemaFilePath(ux_specification_types_1.SchemaType.OverviewPage);
        appSchemas[schemaFile.filename] = generate_1.generateOVPInterfaceV2(genericSchemas[genericSchemaFile.filename], generateParameters.manifest);
    }
    return { ...genericSchemas, ...appSchemas };
}
/**
 * The function generates one app schema per custom page in V4.
 * @param {GenerateAppSchemaParameters} generateParameters List of API input parameters.
 * @param {Schemas} genericSchemas The generic schemas.
 * @param {Schemas} appSchemas The list of app schemas that shall get extended.
 */
function generateCustomPageSchemasV4(generateParameters, genericSchemas, appSchemas) {
    if (!utils_2.isFeatureSupported(generateParameters.featureToggles, ux_specification_types_1.Features.BuildingBlocks)) {
        return;
    }
    const pages = app_1.getPages(generateParameters.manifest, ux_specification_types_1.v4.FE_TEMPLATE_V4_CUSTOM_PAGE);
    for (const pageId in pages) {
        const page = pages[pageId];
        // Resolve view name and app id
        const viewData = utils_1.getPageCustomViewFile(generateParameters.views || [], pageId, generateParameters.manifest);
        const viewId = page['viewId'] || page['id'];
        if (viewData) {
            const schemaFile = utils_2.getSchemaFilePath(ux_specification_types_1.SchemaType.FPMCustomPage, undefined, viewId);
            const genericSchemaFile = utils_2.getSchemaFilePath(ux_specification_types_1.SchemaType.FPMCustomPage);
            appSchemas[schemaFile.filename] = generate_2.generateCustomPageSchemaV4(genericSchemas[genericSchemaFile.filename], viewData, generateParameters.serviceAVT, generateParameters.logger);
        }
    }
}
/**
 * Generates all app specific schemas for a Fiori Elements V4 application
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param {Schemas} genericSchemas - The generic schemas
 * @param {UiEntityTypes} uiEntityTypes - list of all entity types, as comprised in oDataServiceAVT
 * @param {TemplateType} templateType - the given Fiori Elements' template type
 */
function generateAppSchemasV4(generateParameters, genericSchemas, uiEntityTypes) {
    const appSchemas = {};
    if (uiEntityTypes) {
        generateListReportSchemasV4(generateParameters, genericSchemas, appSchemas);
        generateObjectPageSchemasV4(generateParameters, genericSchemas, appSchemas);
        generateCustomPageSchemasV4(generateParameters, genericSchemas, appSchemas);
    }
    return { ...genericSchemas, ...appSchemas };
}
/**
 * Generates app specific schemas by adding annotation information to copies of the generic schemas, thus replacing all generic definitions.
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param {UiEntityTypes} uiEntityTypes - list of all entity types from the service metadata
 * @param templateType - type of the Fiori Elements' template
 */
async function generateAppSchemas(generateParameters, uiEntityTypes, templateType) {
    const genericSchemas = await getGenericSchemas(templateType, generateParameters.fioriElementsVersion);
    if (generateParameters.fioriElementsVersion === ux_specification_types_1.FioriElementsVersion.v4) {
        return generateAppSchemasV4(generateParameters, genericSchemas, uiEntityTypes);
    }
    else {
        return generateAppSchemasV2(generateParameters, genericSchemas, uiEntityTypes, templateType);
    }
}
/**
 * Imports manifest and flex changes into configuration files with aid of the relevant app provider
 * @param {ImportAllConfigsParameters} importParameters - structure comprising all input parameters
 *
 * @returns {File[]} a list of all configuration files as generated by the function
 */
function importConfigs(importParameters) {
    let provider;
    const files = [];
    switch (importParameters.templateType) {
        case ux_specification_types_1.TemplateType.ListReportObjectPageV2:
        case ux_specification_types_1.TemplateType.AnalyticalListPageV2:
            provider = new appProvider_1.V2AppProvider(importParameters);
            break;
        case ux_specification_types_1.TemplateType.AnalyticalListPageV4:
        case ux_specification_types_1.TemplateType.ListReportObjectPageV4:
        case ux_specification_types_1.TemplateType.FreestylePageV4:
            provider = new app_1.V4AppProvider(importParameters);
            break;
        case ux_specification_types_1.TemplateType.OverviewPageV2:
            provider = new ovpProvider_1.V2OvpProvider(importParameters);
            break;
        default:
            break;
    }
    if (provider) {
        const { appConfig, pageConfigs } = provider.createConfigFiles();
        for (const app in appConfig) {
            files.push({ dataSourceUri: app, fileContent: JSON.stringify(appConfig[app], null, 4) });
        }
        for (const config in pageConfigs) {
            files.push({ dataSourceUri: config, fileContent: JSON.stringify(pageConfigs[config], null, 4) });
        }
    }
    return files;
}
function getFileList(appSchemas, configs) {
    let files = [];
    for (const schemaName of Object.keys(appSchemas).sort()) {
        let dataSourceUri;
        if (schemaName === ux_specification_types_1.SchemaType.Application) {
            dataSourceUri = `${ux_specification_types_1.DirName.Schemas}/${ux_specification_types_1.FileName.App[0].toUpperCase()}${ux_specification_types_1.FileName.App.slice(1)}`;
        }
        else {
            dataSourceUri = `${ux_specification_types_1.DirName.Schemas}/${schemaName}.json`;
        }
        files.push({ dataSourceUri, fileContent: JSON.stringify(appSchemas[schemaName], null, 4) });
    }
    if (configs) {
        files = files.concat(configs);
    }
    return files;
}
/**
 * Import the schema and config files for a given project
 * @param {ImportProjectParameters} importParameters - files of the project: manifest, flex changes, odata files
 */
async function importProjectSchema(importProjectParameters) {
    // Initialize i18next
    i18n_1.initI18n();
    const fioriElementsVersion = utils_2.getVersionFromManifest(importProjectParameters.manifest);
    const oDataServiceAVT = utils_2.parseAndMergeAndConvert(importProjectParameters.annotations, importProjectParameters.logger);
    const uiEntityTypes = getAnnotationsForUi(oDataServiceAVT);
    const templateType = utils_2.getTemplateTypeFromManifest(importProjectParameters.manifest, fioriElementsVersion, importProjectParameters.logger);
    const generateParameters = {
        templateType,
        manifest: importProjectParameters.manifest,
        serviceAVT: oDataServiceAVT,
        fragments: importProjectParameters.fragments,
        views: importProjectParameters.views,
        fioriElementsVersion,
        logger: importProjectParameters.logger,
        featureToggles: importProjectParameters.featureToggles
    };
    const appSchemas = await generateAppSchemas(generateParameters, uiEntityTypes, templateType);
    return getFileList(appSchemas);
}
exports.importProjectSchema = importProjectSchema;
/**
 * Import the schema and config files for a given project
 * @param {ImportProjectParameters} importParameters - files of the project: manifest, flex changes, odata files
 */
async function importProjectSchemaAndConfig(importProjectParameters) {
    // Initialize i18next
    i18n_1.initI18n();
    const { manifest, annotations, logger } = importProjectParameters;
    const fioriElementsVersion = utils_2.getVersionFromManifest(manifest);
    const oDataServiceAVT = utils_2.parseAndMergeAndConvert(annotations, logger);
    const templateType = utils_2.getTemplateTypeFromManifest(manifest, fioriElementsVersion, logger);
    //Generate Schemas
    const generateParameters = {
        templateType,
        manifest: importProjectParameters.manifest,
        serviceAVT: oDataServiceAVT,
        fragments: importProjectParameters.fragments,
        views: importProjectParameters.views,
        fioriElementsVersion,
        logger: importProjectParameters.logger,
        featureToggles: importProjectParameters.featureToggles
    };
    const uiEntityTypes = getAnnotationsForUi(oDataServiceAVT);
    const appSchemas = await generateAppSchemas(generateParameters, uiEntityTypes, templateType);
    //Import to configs
    const importConfigsParameters = {
        manifest: importProjectParameters.manifest,
        flexChanges: importProjectParameters.flex,
        appSchemas,
        templateType,
        logger: importProjectParameters.logger,
        serviceAVT: oDataServiceAVT,
        fragments: importProjectParameters.fragments,
        views: importProjectParameters.views
    };
    const configFiles = importConfigs(importConfigsParameters);
    return getFileList(appSchemas, configFiles);
}
exports.importProjectSchemaAndConfig = importProjectSchemaAndConfig;
//# sourceMappingURL=importProject.js.map