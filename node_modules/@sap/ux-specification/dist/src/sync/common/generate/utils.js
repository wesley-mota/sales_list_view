"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addKeyToDefinition = exports.getActionKey = exports.addDescriptiveEnumDefinition = exports.addFieldsType = exports.handleAddressContact = exports.getFacetAnnotationPath = exports.addDefinitionRef = exports.getFacetDefinitionLink = exports.addDataTypeToDefinition = exports.determineDataType = exports.determineDataTypeOfTarget = exports.DataType = exports.addCommonLineItemDefinitions = exports.getCustomExtensionDefinitionName = exports.parseSchemaDefinition = exports.getFacetKeyInSchema = exports.addDefinitionForRelatedFacetKeys = exports.addEnumFieldGroupAnnotationPath = exports.addEnumForFilterBarAnnotationPath = exports.addEnumForVariantEntitySet = exports.addEnumForMultiTabVariant = exports.addEnumForSingleTabVariant = exports.addEnumForValidAnnotations = void 0;
const __1 = require("..");
const ux_specification_types_1 = require("@sap/ux-specification-types");
const StableIdHelper_1 = require("../../v4/utils/StableIdHelper");
/**
 * Adds an enum filled with existing UI annotations of the given list (validAnnotations)
 * @param {EntityType} entityType
 * @param {UIAnnotationTerms[]} validAnnotations
 * @param {Definition} annoPath - the annotation path property in the app schema where the enum shall be added
 */
function addEnumForValidAnnotations(entityType, validAnnotations, annoPath) {
    const UiAnnotations = entityType?.annotations?.UI;
    if (!UiAnnotations) {
        return;
    }
    const enumEntries = [];
    for (const key in UiAnnotations) {
        const annotation = UiAnnotations[key];
        if (validAnnotations.indexOf(annotation.term) > -1) {
            const enumEntry = annotation.qualifier
                ? `${annotation.term}#${annotation.qualifier}`
                : `${annotation.term}`;
            if (enumEntries.indexOf(enumEntry) === -1) {
                enumEntries.push(enumEntry);
            }
        }
    }
    if (enumEntries.length > 0) {
        annoPath.enum = enumEntries;
    }
}
exports.addEnumForValidAnnotations = addEnumForValidAnnotations;
/**
 * Adds an enum filled with existing UI annotations for single-tab variants of a table
 * @param {EntityType} entityType
 * @param {Definition} appSchema - app specific JSON schema
 * @param definitionName - name of the definition in the app schema
 */
function addEnumForSingleTabVariant(entityType, appSchema, definitionName) {
    const annoPath = appSchema.definitions[definitionName].properties[ux_specification_types_1.SchemaTag.annotationPath];
    const validAnnotations = ["com.sap.vocabularies.UI.v1.SelectionVariant" /* SelectionVariant */, "com.sap.vocabularies.UI.v1.SelectionPresentationVariant" /* SelectionPresentationVariant */];
    addEnumForValidAnnotations(entityType, validAnnotations, annoPath);
}
exports.addEnumForSingleTabVariant = addEnumForSingleTabVariant;
/**
 * Adds an enum filled with existing UI annotations for multi-tab variants of a table
 * @param appSchema - app specific JSOn schema
 * @param definitionName - name of the definition in the app schema
 * @param {EntitySet} entitySet - current entity set of the page or view
 */
function addEnumForMultiTabVariant(appSchema, definitionName, entitySet) {
    const annoPath = appSchema.definitions[definitionName]?.properties.annotationPath;
    const validAnnotations = ["com.sap.vocabularies.UI.v1.SelectionVariant" /* SelectionVariant */, "com.sap.vocabularies.UI.v1.SelectionPresentationVariant" /* SelectionPresentationVariant */];
    addEnumForValidAnnotations(entitySet.entityType, validAnnotations, annoPath);
}
exports.addEnumForMultiTabVariant = addEnumForMultiTabVariant;
/**
 * Adds the enum values for entitySet as part of the multiple view scenario
 * @param {ConvertedMetadata} oDataServiceAVT - combined service metadata, as returned by annotation vocabularies tools
 * @param appSchema - app specific JSOn schema
 * @param definitionName - name of the definition in the app schema
 */
function addEnumForVariantEntitySet(oDataServiceAVT, appSchema, definitionName) {
    const entitySet = appSchema.definitions[definitionName].properties.entitySet;
    const enumEntries = [];
    if (!oDataServiceAVT) {
        return;
    }
    oDataServiceAVT.entitySets.forEach((es) => {
        enumEntries.push(es.name);
    });
    if (enumEntries.length > 0) {
        entitySet['enum'] = enumEntries;
    }
}
exports.addEnumForVariantEntitySet = addEnumForVariantEntitySet;
/**
 * Adds an enum filled with existing UI annotations for annotationPath property in FilterBar
 * @param {EntityType} entityType
 * @param appSchema - app specific JSOn schema
 * @param definitionName - name of the definition in the app schema
 */
function addEnumForFilterBarAnnotationPath(entityType, appSchema, definitionName) {
    const annoPath = appSchema.definitions[definitionName].properties.annotationPath;
    const validAnnotations = ["com.sap.vocabularies.UI.v1.SelectionVariant" /* SelectionVariant */];
    addEnumForValidAnnotations(entityType, validAnnotations, annoPath);
}
exports.addEnumForFilterBarAnnotationPath = addEnumForFilterBarAnnotationPath;
/**
 * Adds an enum filled with existing UI FieldGroup annotations for annotationPath property in MultiEdit
 * @param {EntityType} entityType
 * @param appSchema - app specific JSOn schema
 * @param definitionName - name of the definition in the app schema
 */
function addEnumFieldGroupAnnotationPath(entityType, appSchema, definitionName) {
    const annoPath = appSchema.definitions[definitionName].properties.annotationPath;
    const validAnnotations = ["com.sap.vocabularies.UI.v1.FieldGroup" /* FieldGroup */];
    addEnumForValidAnnotations(entityType, validAnnotations, annoPath);
}
exports.addEnumFieldGroupAnnotationPath = addEnumFieldGroupAnnotationPath;
/**
 * Method adds definition for 'RelatedFacetKeys' as enum with description and adds references to 'RelatedFacetKeys' for custom section definitions.
 * @param {Definition} appSchema App specific schema that potentially gets enhanced
 * @param {string[]>} sectionDefinitions array of section definitions which should be updated with new reference to 'RelatedFacetKeys' enum.
 * @param {FacetSection[]} facetSections Array of facet section objects which is used to generate enum values.
 * @param {Array<keyof Omit<FacetSection, 'custom'>>} idProperties Array of property names which should be looked up in 'FacetSection' object.
 *  Please note that method depends on order and takes first non empty value associated to passed properties.
 */
function addDefinitionForRelatedFacetKeys(appSchema, sectionDefinitions, facetSections, idProperties) {
    const oneOfSections = facetSections.map((section) => {
        // Loop acceptable properties in received order and find first entry with value
        const propertyName = idProperties.find((property) => !!section[property]);
        const schemaIdForSection = section[propertyName];
        return {
            const: schemaIdForSection,
            ...(section.label && { description: section.label }),
            ...(section.custom && { custom: section.custom })
        };
    });
    // Change 'relatedFacet' only when we have entries for sections - otherwise use generic.
    if (oneOfSections.length) {
        // Create new definition in schema as 'oneOf'.
        // Simpler way would be to use 'enum', but then there no option to pass description.
        appSchema.definitions[ux_specification_types_1.DefinitionName.RelatedFacetKeys] = {
            type: 'string',
            oneOf: oneOfSections
        };
        // Add enum definition
        for (const name of sectionDefinitions) {
            const definition = appSchema.definitions[name];
            const property = definition.properties['relatedFacet'];
            definition.properties['relatedFacet'] = {
                anyOf: [
                    {
                        $ref: `${__1.DEFINITION_LINK_PREFIX}${ux_specification_types_1.DefinitionName.RelatedFacetKeys}`
                    },
                    property
                ]
            };
        }
    }
}
exports.addDefinitionForRelatedFacetKeys = addDefinitionForRelatedFacetKeys;
/**
 * Receives a facet key and returns the key as used in schema
 * @param facetKey - key of the facet, as used in annotation
 * @returns facetKeyInSchema - key of the facet, as used in schema
 */
function getFacetKeyInSchema(facetKey) {
    return facetKey.replace('#', '::');
}
exports.getFacetKeyInSchema = getFacetKeyInSchema;
/**
 * Returns the name of a facet and definition, as key in definition
 * @param definition name of definition, as used in schema
 * @param facetKey - key of the facet, as used in annotation
 * @returns definition key of facet, as used in definition
 */
function getFacetDefinitionKey(definition, facetKey) {
    return `${definition}<${getFacetKeyInSchema(facetKey)}>`;
}
/**
 * Adds an existing schema definition to a new definition in the app schema
 * @param definition name of definition, as used in schema
 * @param facetKey - key of the facet, as used in annotation
 * @param {Definition} appSchema App schema in general
 * @param {boolean} useDefinitionAsKey If set to false, facet key will solely be used as key, else encapsulated within definition key `definition<facetKey>`
 * @param subDefinitionName - sub definition, if different from the definition (e.g. subsection vs. section)
 * @returns {Definition} part of app schema that has been added and filled
 */
function parseSchemaDefinition(definition, facetKey, appSchema, useDefinitionAsKey = true, subDefinitionName) {
    let facetDefinitionKey = facetKey;
    if (useDefinitionAsKey) {
        facetDefinitionKey = getFacetDefinitionKey(subDefinitionName ? subDefinitionName : definition, facetKey);
    }
    if (definition && definition !== facetDefinitionKey) {
        const schemaDefinition = JSON.parse(JSON.stringify(appSchema.definitions[definition]));
        appSchema.definitions[facetDefinitionKey] = schemaDefinition;
    }
    return appSchema.definitions[facetDefinitionKey];
}
exports.parseSchemaDefinition = parseSchemaDefinition;
/**
 * Method receives custom extension base definition name and detect if it should be combined with lineItemId.
 * @param appSchema - the app specific schema that shall get enhanced
 * @param lineItemId - line item ID, as comprise in stable ID
 * @param customColumnDefinitionName - (optional) definition name of custom extension.
 * @returns $ref path for definition.
 */
function getCustomExtensionDefinitionName(appSchema, lineItemId, customExtensionDefinitionName) {
    let definitionName;
    if (lineItemId === ux_specification_types_1.DefinitionName.LineItems ||
        lineItemId === 'LineItemsOfSPV::LineItem' ||
        lineItemId === '@com.sap.vocabularies.UI.v1.LineItem') {
        definitionName = `${__1.DEFINITION_LINK_PREFIX}${customExtensionDefinitionName}`;
    }
    else {
        definitionName = `${__1.DEFINITION_LINK_PREFIX}${customExtensionDefinitionName}<${lineItemId}>`;
        parseSchemaDefinition(customExtensionDefinitionName, lineItemId, appSchema, true);
    }
    return definitionName;
}
exports.getCustomExtensionDefinitionName = getCustomExtensionDefinitionName;
/**
 * Functions used both by V2 and V4 to add the common definitions for a line item to the app schema
 * @param appSchema - the app specific schema that shall get enhanced
 * @param lineItemAnnotation - the UI.LineItem annotation, comprising all records
 * @param entityType - the entity type as part of the AVT ConvertedMetadata
 * @param lineItemId - line item ID, as comprise in stable ID
 * @param customColumnDefinitionName - (optional) definition name of custom column.
 *        Passed in the V4 case, then additional properties of this type will be allowed.
 * @returns the actions definition plus the annotation path to the given line item
 */
function addCommonLineItemDefinitions(appSchema, lineItemAnnotation, entityType, lineItemId, customColumnDefinitionName, customActionDefinitionName) {
    let lineItemPath;
    appSchema.definitions[lineItemId] = {
        type: 'object',
        properties: {},
        description: 'Columns'
    };
    appSchema.definitions[lineItemId][ux_specification_types_1.SchemaTag.isViewNode] = true;
    const customColumnRef = getCustomExtensionDefinitionName(appSchema, lineItemId, customColumnDefinitionName);
    appSchema.definitions[lineItemId].additionalProperties = customColumnDefinitionName
        ? { $ref: customColumnRef }
        : false;
    // Copy toolbar
    const toolBar = lineItemId.startsWith(ux_specification_types_1.DefinitionName.LineItems)
        ? ux_specification_types_1.DefinitionName.ToolBar
        : ux_specification_types_1.DefinitionName.ObjectPageToolBar;
    const schemaIdForToolBar = `${toolBar}<${lineItemId}>`;
    appSchema.definitions[schemaIdForToolBar] = JSON.parse(JSON.stringify(appSchema.definitions[`${toolBar}`]));
    const schemaIdForActions = `${ux_specification_types_1.DefinitionName.Actions}<${__1.prepareRef(lineItemId)}>`;
    appSchema.definitions[schemaIdForToolBar].properties.actions['$ref'] =
        __1.DEFINITION_LINK_PREFIX + schemaIdForActions;
    const actionId = lineItemId.startsWith(ux_specification_types_1.DefinitionName.LineItems)
        ? ux_specification_types_1.DefinitionName.Actions
        : ux_specification_types_1.DefinitionName.ObjectPageToolBarActions;
    const actions = (appSchema.definitions[schemaIdForActions] = JSON.parse(JSON.stringify(appSchema.definitions[actionId])));
    actions.properties = {};
    // Handle actions additional properties - add custom action reference if it is supported
    actions.additionalProperties = false;
    if (customActionDefinitionName) {
        const customActionRef = getCustomExtensionDefinitionName(appSchema, lineItemId, customActionDefinitionName);
        actions.additionalProperties = { $ref: customActionRef };
    }
    // Copy LR footer
    let footerActions, schemaIdForFooter;
    if (lineItemId === ux_specification_types_1.DefinitionName.LineItems && appSchema.properties['footer']) {
        schemaIdForFooter = `${ux_specification_types_1.DefinitionName.Footer}<${lineItemId}>`;
        appSchema.properties['footer'].$ref = `${__1.DEFINITION_LINK_PREFIX}${schemaIdForFooter}`;
        appSchema.definitions[schemaIdForFooter] = JSON.parse(JSON.stringify(appSchema.definitions[ux_specification_types_1.DefinitionName.GenericFooter]));
        const schemaIdForFooterActions = `${ux_specification_types_1.DefinitionName.FooterActions}<${__1.prepareRef(lineItemId)}>`;
        appSchema.definitions[schemaIdForFooter].properties.actions['$ref'] =
            __1.DEFINITION_LINK_PREFIX + schemaIdForFooterActions;
        footerActions = appSchema.definitions[schemaIdForFooterActions] = JSON.parse(JSON.stringify(appSchema.definitions[ux_specification_types_1.DefinitionName.Actions]));
        footerActions.properties = {};
        footerActions.additionalProperties = false;
    }
    //Determine annotation path
    if (lineItemAnnotation) {
        lineItemPath = __1.createAnnotationPath(entityType.fullyQualifiedName, lineItemAnnotation.term, lineItemAnnotation.qualifier);
        appSchema.definitions[schemaIdForToolBar][ux_specification_types_1.SchemaTag.annotationPath] = lineItemPath;
        if (footerActions) {
            appSchema.definitions[schemaIdForFooter][ux_specification_types_1.SchemaTag.annotationPath] = lineItemPath;
        }
    }
    return { actions, footerActions, lineItemPath };
}
exports.addCommonLineItemDefinitions = addCommonLineItemDefinitions;
var DataType;
(function (DataType) {
    DataType["String"] = "String";
    DataType["Rating"] = "Rating";
    DataType["Progress"] = "Progress";
    DataType["DataPoint"] = "DataPoint";
    DataType["Contact"] = "Contact";
    DataType["Address"] = "Address";
    DataType["Chart"] = "Chart";
    DataType["FieldGroup"] = "FieldGroup";
    DataType["IntentBasedNavigation"] = "IntentBasedNavigation";
})(DataType = exports.DataType || (exports.DataType = {}));
/**
 * Determines the dataType of the target that shall be added to a property in schema
 * @param target - the given target
 * @returns - the dataType as string
 */
function determineDataTypeOfTarget(target) {
    let dataType;
    if (target.Value) {
        if (target.Visualization === 'UI.VisualizationType/Rating') {
            dataType = DataType.Rating;
        }
        else if (target.Visualization === 'UI.VisualizationType/Progress') {
            dataType = DataType.Progress;
        }
        else if (target.$Type === 'com.sap.vocabularies.UI.v1.DataPointType') {
            dataType = DataType.DataPoint;
        }
        else {
            dataType = target.Value?.$target?.type.replace('Edm.', '');
        }
    }
    else if (target.$Type === 'com.sap.vocabularies.Communication.v1.ContactType') {
        dataType = DataType.Contact;
    }
    else if (target.$Type === 'com.sap.vocabularies.Communication.v1.AddressType') {
        dataType = DataType.Address;
    }
    else if (target.$Type === 'com.sap.vocabularies.UI.v1.ChartDefinitionType') {
        dataType = DataType.Chart;
    }
    else if (target.$Type === 'com.sap.vocabularies.UI.v1.FieldGroupType') {
        dataType = DataType.FieldGroup;
    }
    return dataType;
}
exports.determineDataTypeOfTarget = determineDataTypeOfTarget;
/**
 * Determines the dataType that shall be added to a property in schema, for any kind of field like
 * - field of a field group
 * - line item record
 * - selection field
 * @param field - the given field
 * @returns - the dataType as string
 */
function determineDataType(field) {
    let dataType;
    if (field['Value']) {
        if (field['Value'].$target?.type) {
            dataType = field['Value'].$target.type.replace('Edm.', '');
        }
        else {
            dataType = DataType.String;
        }
    }
    else if (field['Target']) {
        dataType = determineDataTypeOfTarget(field['Target'].$target);
    }
    else if (field['$target']) {
        dataType = field['$target'].type.replace('Edm.', '');
    }
    else if (field['$Type'] === 'com.sap.vocabularies.UI.v1.DataFieldForAction') {
        dataType = 'Action';
    }
    else if (field['$Type'] === 'com.sap.vocabularies.UI.v1.DataFieldWithUrl') {
        dataType = 'Url';
    }
    else if (field['$Type'] === 'com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation') {
        dataType = DataType.IntentBasedNavigation;
    }
    else if (field['type']) {
        dataType = field['type'];
    }
    return dataType;
}
exports.determineDataType = determineDataType;
/**
 * Adds the dataType to the given schema field definition, if the data type cane be determined
 * @param definition - given schema definition
 * @param field - given field definition = annotation property, at AVT
 */
function addDataTypeToDefinition(definition, field) {
    const dataType = determineDataType(field);
    if (dataType) {
        definition[ux_specification_types_1.SchemaTag.dataType] = dataType;
    }
}
exports.addDataTypeToDefinition = addDataTypeToDefinition;
/**
 * Creates a definition link for a facet and definition name
 * @param {DefinitionName} definition - name of definition, as used in schema
 * @param {string} facetKey - key of the facet, as used in annotation
 * @returns definition link of facet, as used in definition
 */
function getFacetDefinitionLink(definition, facetKey) {
    return `${__1.DEFINITION_LINK_PREFIX}${getFacetDefinitionKey(definition, facetKey)}`;
}
exports.getFacetDefinitionLink = getFacetDefinitionLink;
/**
 * Creates and adds a reference link to a definition
 * @param {Definition} schemaPart - part of schema to add $ref to
 * @param {string} schemaRef - reference to be added
 * @param {string} schemaKey - key to be encapsulated within reference as `schemaRef<schemaKey>`
 * @returns reference link of facet, as used in definition
 */
function addDefinitionRef(schemaPart, schemaRef, schemaKey) {
    const schemaLink = schemaKey ? `${schemaRef}<${schemaKey}>` : schemaRef;
    schemaPart.$ref = `${__1.DEFINITION_LINK_PREFIX}${schemaLink}`;
}
exports.addDefinitionRef = addDefinitionRef;
/**
 * Extracts annotationPath from facet or Chart/LineItem fullyQualifiedName
 * @param facet facet or Chart/LineItem
 * @returns {string} annotationPath
 */
function getFacetAnnotationPath(facet) {
    if (facet.annotationPath) {
        return facet.annotationPath;
    }
    else if (facet.fullyQualifiedName) {
        const [namespace, target] = facet.fullyQualifiedName.split(`@${ux_specification_types_1.UIVOCABULARY}`);
        return `/${namespace}/@${ux_specification_types_1.UIVOCABULARY}${target}`;
    }
    return undefined;
}
exports.getFacetAnnotationPath = getFacetAnnotationPath;
/**
 * Adds definitions for Address and Contact items in object page sections to the app schema
 * @param {FacetConfig} facet - current facet.
 * @param {string} facetKey - facet key.
 * @param {object} sections - schema of current sections definition.
 * @param {object} appSchema - app specific schema that potentially gets enhanced.
 * @param {SectionType} sectionPrefix - prefix to distinguish Section and HeaderSection
 */
function handleAddressContact(facet, facetKey, sections, appSchema, sectionPrefix, subSectionPrefix, versionPostfix = '') {
    const definitionName = `ObjectPage${sectionPrefix}${facet.base}${versionPostfix}`;
    const subDefinitionName = `ObjectPage${subSectionPrefix}${facet.base}${versionPostfix}`;
    sections.properties[facetKey] = {
        $ref: getFacetDefinitionLink(subSectionPrefix ? subDefinitionName : definitionName, facetKey)
    };
    const definition = parseSchemaDefinition(subSectionPrefix ? subDefinitionName : definitionName, facetKey, appSchema, true, subSectionPrefix ? subDefinitionName : undefined);
    __1.addSectionTitleAndDescription(facet, definition, facetKey);
    definition[ux_specification_types_1.SchemaTag.annotationPath] = facet.annotationPath;
    definition[ux_specification_types_1.SchemaTag.isViewNode] = true;
}
exports.handleAddressContact = handleAddressContact;
/**
 * Method updates schema definition's property.
 * @param {DefinitionOrBoolean} definition Definition object.
 * @param {string} key Property name.
 * @param {unknown} value New value.
 */
function updateSchemaProperty(definition, key, value) {
    if (typeof definition === 'object') {
        definition[key] = value;
    }
}
/**
 * Add schema definitions for fields of createWithParameterDialog
 * @param {object} appSchema - Application-specific schema, to be enhanced
 * @param {EntityType} entityType - Given entity type for which entries shall get generated
 * @param {string=} suffix - floorplan specific suffix (optional)
 */
function addFieldsType(appSchema, entityType, suffix = __1.prepareRef('')) {
    const itemsEnum = entityType.entityProperties.map((property) => property.name);
    const fields4Dialog = appSchema.definitions[`${ux_specification_types_1.DefinitionName.Fields4Dialog}${suffix}`];
    updateSchemaProperty(fields4Dialog.properties.fields['items'], 'enum', itemsEnum);
}
exports.addFieldsType = addFieldsType;
/**
 * Method returns description for passed schema definition.
 * @param {Definition} appSchema App specific JSON schema
 * @param {Definition} definition Target definition to resolve description.
 * @param {boolean} resolveDefinition Should logic use fallback to look into reference definition.
 * @returns {string | undefined} Description of passed definition.
 */
function getDescription(appSchema, definition, resolveDefinition = false) {
    let description = definition.description;
    if (resolveDefinition && !description && definition.$ref) {
        // Try to read description from reference
        const definitionKey = __1.getDefinitionKey(definition.$ref);
        const refDefinition = appSchema.definitions?.[definitionKey];
        if (typeof refDefinition === 'object') {
            description = refDefinition.description;
        }
    }
    return description;
}
/**
 * Method adds enum with key and description to schema definition.
 * Description can be easily used by UI to describe enum value/key.
 * @param {Definition} appSchema App specific JSON schema
 * @param {DefinitionOrBoolean} origin Origin schema object containing key and description.
 * @param {PropertyInDefinition} target Target to update with enum.
 * @param {EnumDefinitionParsingOptions} [options] Additional parsing options.
 * @param {boolean} resolveDefinition Should logic use fallback to look into reference definition.
 */
function addDescriptiveEnumDefinition(appSchema, origin, target, options) {
    if (typeof origin !== 'object') {
        // Safe checks
        return;
    }
    const oneOfEnum = [];
    for (const key in origin.properties) {
        if (options?.excludeKey === key) {
            continue;
        }
        const property = origin.properties[key];
        const description = getDescription(appSchema, property, options?.resolveDefinition);
        oneOfEnum.push({
            const: key,
            ...(description && { description })
        });
    }
    const definition = appSchema.definitions[target.definition] || target.schema;
    if (typeof definition === 'object') {
        if (target.property) {
            const property = definition.properties?.[target.property];
            updateSchemaProperty(property, 'oneOf', oneOfEnum);
        }
        else {
            updateSchemaProperty(definition, 'oneOf', oneOfEnum);
        }
    }
}
exports.addDescriptiveEnumDefinition = addDescriptiveEnumDefinition;
/**
 * Extracts the key of an action that shall be added to schema as SchemaTag.keys
 * @param action - full-blown action ID
 * @param isAction - indicates an action
 * @returns action ID stripped down to the last key part
 */
function getActionKey(action, isAction) {
    let actionKey = action;
    let namespace;
    if (actionKey.indexOf('(') > 0) {
        actionKey = actionKey.substring(0, actionKey.indexOf('('));
    }
    if (isAction && actionKey.indexOf('/') > 0) {
        namespace = actionKey.substring(0, actionKey.indexOf('/'));
        actionKey = actionKey.substring(actionKey.lastIndexOf('/') + 1);
    }
    if (isAction && actionKey.indexOf('.') > 0) {
        namespace = actionKey.substring(0, actionKey.lastIndexOf('.'));
        actionKey = actionKey.substring(actionKey.lastIndexOf('.') + 1);
    }
    if (!namespace) {
        namespace = action.substring(0, action.lastIndexOf('.'));
    }
    return { key: actionKey.replace(/@/g, ''), ns: namespace };
}
exports.getActionKey = getActionKey;
/**
 * Adds the schema tag key to a line item record or property in schema
 * @param lineItemRecord - the given line item record
 * @param properties - list of all properties in schema
 * @param schemaKey - key of the given property
 */
function addKeyToDefinition(lineItemRecord, properties, schemaKey) {
    if (lineItemRecord['Value']) {
        properties[schemaKey][ux_specification_types_1.SchemaTag.keys] = [
            { name: ux_specification_types_1.SchemaKeyName.value, value: StableIdHelper_1.getStableIdPartFromValue(lineItemRecord['Value']) }
        ];
    }
    else if (lineItemRecord['$Type'] === "com.sap.vocabularies.UI.v1.DataFieldWithAction" /* DataFieldWithAction */ ||
        lineItemRecord['$Type'] === "com.sap.vocabularies.UI.v1.DataFieldForAction" /* DataFieldForAction */) {
        const { key, ns } = getActionKey(lineItemRecord['Action'], true);
        properties[schemaKey][ux_specification_types_1.SchemaTag.keys] = [{ name: ux_specification_types_1.SchemaKeyName.action, value: key }];
        if (ns) {
            properties[schemaKey][ux_specification_types_1.SchemaTag.target] = ns;
        }
    }
    else if (lineItemRecord['$Type'] === "com.sap.vocabularies.UI.v1.DataFieldForAnnotation" /* DataFieldForAnnotation */) {
        const { key } = getActionKey(lineItemRecord['Target'].value, false);
        properties[schemaKey][ux_specification_types_1.SchemaTag.keys] = [
            { name: ux_specification_types_1.SchemaKeyName.target, value: key.replace(/com.sap.vocabularies.UI.v1./g, '') }
        ];
        properties[schemaKey][ux_specification_types_1.SchemaTag.target] = lineItemRecord['Target'].$target.fullyQualifiedName.split('@')[0];
    }
    else if (lineItemRecord['$Type'] === "com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation" /* DataFieldForIntentBasedNavigation */ ||
        lineItemRecord['$Type'] === "com.sap.vocabularies.UI.v1.DataFieldWithIntentBasedNavigation" /* DataFieldWithIntentBasedNavigation */) {
        const keyParts = schemaKey.split('::');
        properties[schemaKey][ux_specification_types_1.SchemaTag.keys] = [
            { name: `Property`, value: keyParts[keyParts.length - 1] },
            { name: `SemanticObject`, value: lineItemRecord['SemanticObject'] },
            { name: `Action`, value: lineItemRecord['Action'] }
        ];
    }
}
exports.addKeyToDefinition = addKeyToDefinition;
//# sourceMappingURL=utils.js.map