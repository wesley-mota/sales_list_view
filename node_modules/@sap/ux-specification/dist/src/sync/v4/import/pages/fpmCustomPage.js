"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCustomPageConfig = void 0;
const utils_1 = require("../../utils/utils");
const macros_1 = require("../../utils/macros");
/**
 * Method checks if passed string value and schema matches to boolean type.
 * @param {string} value Attribute value from xml file.
 * @param {SchemaDefinition} schema Property's schema containing information about property type.
 * @returns {boolean} Is value a boolean type.
 */
function isBoolean(value, schema) {
    const schemaBoolean = 'boolean';
    if (schema.type === schemaBoolean ||
        schema.anyOf?.find((entry) => entry.type === schemaBoolean)) {
        return value === 'true' || value === 'false';
    }
    return false;
}
/**
 * Method checks if passed string value and schema matches to number type.
 * @param {string} value Attribute value from xml file.
 * @param {SchemaDefinition} schema Property's schema containing information about property type.
 * @returns {boolean} Is value a number type.
 */
function isNumber(value, schema) {
    const schemaNumber = 'number';
    if (schema.type === schemaNumber || schema.anyOf?.find((entry) => entry.type === schemaNumber)) {
        return !isNaN(parseFloat(value.toString()));
    }
    return false;
}
/**
 * Method converts string value from XML file attribute to strict type depending on property's schema.
 * @param {string | number} value Attribute value from xml file.
 * @param {SchemaDefinition} schema Property's schema containing information about property type.
 * @returns {unknown} Converted value.
 */
function convertValue(value, schema) {
    const valueStr = value.toString();
    if (isBoolean(valueStr, schema)) {
        return valueStr === 'true' ? true : false;
    }
    if (isNumber(valueStr, schema)) {
        return parseFloat(valueStr);
    }
    return value;
}
/**
 * Callback method of traversing schema and XML.
 * Method imports value from XML element to page config object.
 * @param {TraverseData} traverseData Schema and XML traverse data.
 * @param {SchemaDefinition} property Schema property to use for import.
 * @param {object} config Fragment of page config object.
 * @param {string} name Name of property to import.
 * @returns {boolean} Is new value differs.
 */
function importProperty(traverseData, property, config, name) {
    const { element } = traverseData;
    let differs = false;
    if (element.attributes && name in element.attributes) {
        const value = convertValue(element.attributes[name], property);
        if (value !== config[name]) {
            config[name] = value;
            differs = true;
        }
    }
    return differs;
}
/**
 * Imports the content of fpm custom page by parsing associated view file.
 * @param {ImportFPMCustomPageV4Parameters} importParameters Object comprising all input data.
 * @param {FeatureToggle[]} [featureToggles] - array of supported features.
 * @returns {v4.ListReportConfigV4 | undefined} Result of import.
 */
function createCustomPageConfig(importParameters) {
    const { views, manifest, jsonSchema, routingId, logger } = importParameters;
    if (!jsonSchema || Object.keys(jsonSchema).length === 0) {
        // Unsupported feature
        return undefined;
    }
    const viewData = utils_1.getPageCustomViewFile(views || [], routingId, manifest);
    let config;
    if (viewData) {
        const element = macros_1.parseXML(viewData.file, false, logger);
        if (element) {
            const coreElement = element.elements?.[0];
            config = {};
            const schema = jsonSchema;
            macros_1.traverseSchema({
                fullSchema: schema,
                schema: schema,
                element: coreElement,
                contextPath: [],
                config
            }, importProperty);
        }
    }
    return config;
}
exports.createCustomPageConfig = createCustomPageConfig;
//# sourceMappingURL=fpmCustomPage.js.map