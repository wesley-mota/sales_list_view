"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.exportPageV4 = exports.defaultExportResult = void 0;
const exportCustomColumn_1 = require("./exportCustomColumn");
const common_1 = require("../../common");
const application_1 = require("../application");
const manifest_1 = require("./manifest");
const flexibleColumnLayout_1 = require("./flexibleColumnLayout");
const ux_specification_types_1 = require("@sap/ux-specification-types");
const utils_1 = require("../../common/utils");
const factory_1 = require("./factory");
const utils_2 = require("./utils");
const fpmCustomPage_1 = require("./fpmCustomPage");
exports.defaultExportResult = {
    flexChanges: [],
    manifest: {
        'sap.ui5': {
            flexEnabled: true,
            routing: {
                targets: {}
            }
        },
        'sap.app': {}
    },
    fragments: [],
    views: []
};
/**
 * Applies the sync rule for a flex change during export
 * @param syncRule - export rule from the object classes decorator
 * @param transferParameters - list of parameters passed from API
 * @param ids - list of parent & child ids
 * @param breadcrumbs - list of breadcrumbs, i.e. ID parts for building the stable ID
 * @param title - title from the app schema (comprising for instance the facet ID)
 * @param configObject - current (sub)object of the configuration file
 * @param key - key of the given property
 */
function exportFlexChange(syncRule, transferParameters, ids, breadcrumbs, configObject, key) {
    const controlId = syncRule.flex.controlId(transferParameters.baseId, ids, breadcrumbs, syncRule.flex.controlType, transferParameters.title);
    const flexChange = common_1.fillFlexChangeContent(configObject, syncRule, transferParameters.ui5Version, key, controlId);
    transferParameters.exportResults.flexChanges.push(syncRule.flex.createFlexChange(flexChange, transferParameters.exportResults.manifest));
}
function determineTargetAnnotationOfTable(ids, transferParameters, configObject) {
    let targetAnnotationEncoded = '@com.sap.vocabularies.UI.v1.LineItem';
    let targetAnnotation = '@com.sap.vocabularies.UI.v1.LineItem';
    const annotationPath = transferParameters.appSchema.definitions[ux_specification_types_1.DefinitionName.TableSPV]?.[ux_specification_types_1.SchemaTag.annotationPath];
    if (ids.length > 1 && transferParameters.config['table'].annotationPath) {
        const annoPath = transferParameters.appSchema.definitions[ux_specification_types_1.DefinitionName.ALPTable]?.[ux_specification_types_1.SchemaTag.annotationPath];
        targetAnnotationEncoded = targetAnnotation = annoPath && annoPath.substr(annoPath.lastIndexOf('@'));
    }
    else if (configObject.table?.annotationPath) {
        //view definition
        targetAnnotationEncoded = targetAnnotation = `@${configObject.table.annotationPath}`;
    }
    else if (ids[0] === ux_specification_types_1.PropertyName.table && annotationPath) {
        const annotationPathArray = annotationPath.split('/');
        targetAnnotationEncoded = targetAnnotation = annotationPathArray[annotationPathArray.length - 1];
    }
    return { targetAnnotationEncoded, targetAnnotation };
}
function determineTargetAnnotationOfChart(ids, transferParameters, targetAnnotationEncoded, targetAnnotation, configObject) {
    if (ids.length > 1) {
        const annoPath = transferParameters.appSchema.definitions[ux_specification_types_1.DefinitionName.ALPChart]?.[ux_specification_types_1.SchemaTag.annotationPath];
        targetAnnotationEncoded = targetAnnotation = annoPath && annoPath.substr(annoPath.lastIndexOf('@'));
    }
    else {
        //chart level
        targetAnnotationEncoded = targetAnnotation = `@${configObject.chart?.annotationPath}`;
    }
    return { targetAnnotationEncoded, targetAnnotation };
}
function determineTargetAnnotationOfViews(transferParameters, ids, targetAnnotation, targetAnnotationEncoded) {
    const parentDefinition = transferParameters.appSchema.definitions['MultiTableModeV4']?.properties[ids[2]];
    if (parentDefinition) {
        if (ids.length === 3) {
            //the parent definition comprises the annotation of the visualization of the (Selection)PresentationVariant.
            targetAnnotation = targetAnnotationEncoded =
                parentDefinition[ux_specification_types_1.SchemaTag.annotationPath] &&
                    parentDefinition[ux_specification_types_1.SchemaTag.annotationPath].substr(parentDefinition[ux_specification_types_1.SchemaTag.annotationPath].lastIndexOf('@'));
        }
        else if (ids.length > 3) {
            //the own definition comprises the lineItem or chart annotation from the visualization
            const ownDefinitionName = parentDefinition.$ref?.split(common_1.DEFINITION_LINK_PREFIX)[1];
            const ownDefinition = ownDefinitionName && transferParameters.appSchema.definitions[ownDefinitionName];
            const annotation = ownDefinition?.[ux_specification_types_1.SchemaTag.annotationPath] &&
                ownDefinition[ux_specification_types_1.SchemaTag.annotationPath].substr(ownDefinition[ux_specification_types_1.SchemaTag.annotationPath].lastIndexOf('@'));
            targetAnnotation = targetAnnotationEncoded = ownDefinition['navigationProperty']
                ? `${ownDefinition['navigationProperty']}/${annotation}`
                : annotation;
        }
    }
    return { targetAnnotation, targetAnnotationEncoded };
}
function determineTargetAnnotationOfSections(ids, custom, targetAnnotationEncoded, targetAnnotation) {
    if (ids[1] === 'custom' && ids[2] !== ids[ids.length - 1]) {
        custom = true;
        targetAnnotationEncoded = ids[2];
        targetAnnotation = targetAnnotationEncoded && targetAnnotationEncoded.replace(/::/g, '/');
    }
    else {
        const sectionId = utils_2.extractLastIdPart(ids[1]);
        targetAnnotationEncoded = sectionId && sectionId.replace(/\//g, '::');
        targetAnnotation = targetAnnotationEncoded && targetAnnotationEncoded.replace(/::/g, '/');
    }
    return { custom, targetAnnotationEncoded, targetAnnotation };
}
/**
 * Determines the target annotation that is relevant for the sync rule
 * @param {string[]} ids - list of ids of parent elements
 * @param {TransferParameterTypeV4} transferParameters - list of parameters passed from API
 * @param { [key: string]: any } configObject - the given config.json, to be exported
 * @returns { targetAnnotationEncoded, targetAnnotation, custom }
 */
function determineTargetAnnotation(ids, transferParameters, configObject) {
    let targetAnnotation, targetAnnotationEncoded, custom = false;
    if (ids[0] === ux_specification_types_1.PropertyName.table && ids[1] !== ux_specification_types_1.PropertyName.views) {
        ({ targetAnnotationEncoded, targetAnnotation } = determineTargetAnnotationOfTable(ids, transferParameters, configObject));
    }
    else if (ids[0] === ux_specification_types_1.PropertyName.chart && transferParameters.templateType === ux_specification_types_1.TemplateType.AnalyticalListPageV4) {
        ({ targetAnnotationEncoded, targetAnnotation } = determineTargetAnnotationOfChart(ids, transferParameters, targetAnnotationEncoded, targetAnnotation, configObject));
    }
    else if (ids[0] === ux_specification_types_1.PropertyName.sections) {
        ({ custom, targetAnnotationEncoded, targetAnnotation } = determineTargetAnnotationOfSections(ids, custom, targetAnnotationEncoded, targetAnnotation));
    }
    else if (ids[1] === ux_specification_types_1.PropertyName.sections) {
        //header sections
        if (transferParameters.title && transferParameters.title.indexOf(ux_specification_types_1.FacetTitlePrefix) > -1) {
            targetAnnotation = targetAnnotationEncoded = transferParameters.title.split(ux_specification_types_1.FacetTitlePrefix)[1];
        }
        else if (ids[2]) {
            targetAnnotation = targetAnnotationEncoded = ids[2].split('@')[1];
        }
        else if (targetAnnotationEncoded) {
            targetAnnotation = targetAnnotationEncoded = targetAnnotationEncoded.replace(/::/g, '/');
        }
    }
    else if (ids[1] === ux_specification_types_1.PropertyName.views) {
        ({ targetAnnotation, targetAnnotationEncoded } = determineTargetAnnotationOfViews(transferParameters, ids, targetAnnotation, targetAnnotationEncoded));
    }
    return { targetAnnotationEncoded, targetAnnotation, custom };
}
/**
 * Calculates an additional key for the sync rule from the given ID's
 * @param {string[]} ids - list of ids of parent elements
 * @returns the key for the sync rule
 */
function determineKeyForSyncRule(ids) {
    let idIndex = 0;
    for (let index = ids.length - 1; index > -1; index--) {
        const element = ids[index];
        if (element === ux_specification_types_1.PropertyName.actions ||
            element === ux_specification_types_1.PropertyName.columns ||
            element === ux_specification_types_1.PropertyName.views ||
            element === ux_specification_types_1.PropertyName.visualFilters) {
            idIndex = index + 1;
            break;
        }
    }
    return idIndex > 0 ? ids[idIndex].replace(/\//gi, '??') : undefined;
}
/**
 * Creates a new object in manifest
 * @param {ExportToManifestParams} params - list of parameters
 */
function createNewObjectInManifest(params) {
    if (params.exportHandler && typeof params.exportHandler === 'function') {
        params.exportHandler(params.manifestSection, params.configObject, params.configPropertyKey, params.manifestKey, params.syncRuleKey);
    }
    else if (!params.manifestSection[params.manifestKey]) {
        params.manifestSection[params.manifestKey] = {};
    }
}
/**
 * Transfers a property value from config to manifest
 * @param {ExportToManifestParams} params - list of parameters
 * @param propertyDefinition - schema definition of a particular property
 * @param nextDefinition - schema definition referred by $ref
 */
function transferPropertyToManifest(params, propertyDefinition, nextDefinition) {
    if (!(propertyDefinition['type'] !== 'array' &&
        nextDefinition?.['targetDefinition']?.type === 'object' &&
        nextDefinition?.['targetDefinition']?.properties)) {
        if (params.exportHandler !== false) {
            if (params.exportHandler && typeof params.exportHandler === 'function') {
                params.exportHandler(params.manifestSection, params.configObject, params.configPropertyKey, params.manifestKey, params.syncRuleKey);
            }
            else if (Array.isArray(params.configObject[params.configPropertyKey]) &&
                !params.configObject[params.configPropertyKey].length) {
                delete params.manifestSection[params.manifestKey];
            }
            else {
                params.manifestSection[params.manifestKey] = params.configObject[params.configPropertyKey];
            }
        }
    }
    else if (propertyDefinition['type'] !== 'array' && params.manifestSection[params.manifestKey] === undefined) {
        createNewObjectInManifest(params);
    }
}
/**
 * Transfers a change in config.json to manifest
 * @param ids - list of parent & child ids
 * @param {SyncRule} syncRule - syncRule (metadata)
 * @param {TransferParameterTypeV4} transferParameters - list of parameters passed from API
 * @param {string} configPropertyKey - key of property in the config
 * @param { [key: string]: any } configObject - the given config.json, to be exported
 * @param propertyDefinition - schema definition of a particular property
 * @param nextDefinition - schema definition referred by $ref
 */
function exportManifestChange(ids, syncRule, transferParameters, configPropertyKey, configObject, propertyDefinition, nextDefinition) {
    //eliminate subsections' hierarchy
    let index = ids.indexOf('subsections');
    while (index > -1) {
        ids.splice(index - 1, 2);
        index = ids.indexOf('subsections');
    }
    const { targetAnnotationEncoded, targetAnnotation, custom } = determineTargetAnnotation(ids, transferParameters, configObject);
    const syncRuleKey = determineKeyForSyncRule(ids);
    const path = syncRule.manifest.path(transferParameters.pageNameArray, transferParameters.exportResults.manifest, targetAnnotationEncoded, syncRuleKey, targetAnnotation, configObject);
    const manifestSection = common_1.getManifestSectionByPathV4(transferParameters.exportResults.manifest, path, targetAnnotation, custom ? undefined : targetAnnotationEncoded);
    if (manifestSection) {
        const manifestKey = syncRule.manifest.key || configPropertyKey;
        if (configObject[configPropertyKey] !== undefined) {
            // In case of arrays we take over complete array
            const exportParams = {
                exportHandler: syncRule.manifest.export,
                manifestSection,
                configObject,
                configPropertyKey,
                manifestKey,
                syncRuleKey
            };
            transferPropertyToManifest(exportParams, propertyDefinition, nextDefinition);
        }
        else if (syncRule.manifest.delete) {
            const deleteHandler = syncRule.manifest.delete;
            if (typeof deleteHandler === 'function') {
                deleteHandler(manifestSection, configObject, configPropertyKey, manifestKey, syncRuleKey, transferParameters.config);
            }
        }
        else if (manifestSection[manifestKey] !== undefined) {
            delete manifestSection[manifestKey];
        }
    }
    utils_1.deleteEmptyStructure(transferParameters.exportResults.manifest, path, targetAnnotation, targetAnnotationEncoded);
}
/**
 * Evaluates an export rule for a property or object, transfers to flex change or manifest setting
 * @param transferParameters - list of parameters passed from API
 * @param breadcrumbs - list of breadcrumbs, i.e. ID parts for building the stable ID
 * @param key - key of the given property
 * @param configObject - current (sub)object of the configuration file
 * @param ids - list of parent & child ids
 * @param title - title from the app schema (comprising for instance the facet ID)
 * @param propertyDefinition - schema definition of a particular property
 * @param nextDefinition - schema definition referred by $ref
 */
function evaluateExportRule(transferParameters, breadcrumbs, key, configObject, ids, propertyDefinition, nextDefinition) {
    const syncRule = common_1.getReflectMetadata(configObject, key);
    if (syncRule) {
        if (syncRule.flex) {
            exportFlexChange(syncRule, transferParameters, ids, breadcrumbs, configObject, key);
        }
        else if (syncRule.manifest) {
            exportManifestChange(ids, syncRule, transferParameters, key, configObject, propertyDefinition, nextDefinition);
        }
    }
}
/**
 * Processes an (object-like) sub-object of the app schema and transfer all connected config entries to manifest
 * @param {TransferEntryParameters} parameters - list of parameters
 * @param {NextDefinition} nextDefinition - the next definition in app schema to be processed
 * @param currentConfigObject - current config object
 * @param ids - list of parent & child ID's
 * @param localIdParts - list of ID parts for building the stable ID
 */
function transferSubObject(parameters, nextDefinition, currentConfigObject, ids, localIdParts) {
    let objects = [], isArray = false;
    if (parameters.propertyDefinition.$ref && nextDefinition) {
        objects.push(nextDefinition.configObject);
    }
    else if (parameters.propertyDefinition['anyOf']) {
        objects.push(currentConfigObject);
    }
    else if (parameters.propertyDefinition.type === 'array') {
        objects = currentConfigObject;
        isArray = true;
    }
    else {
        objects.push(currentConfigObject);
    }
    parameters.index = 0;
    for (const innerObject of objects) {
        const additionalIds = [];
        if (parameters.breadcrumbs[0] === ux_specification_types_1.PropertyName.sections && parameters.key === 'custom' && isArray) {
            // We need add custom section 'id' into breadcrumbs to retrieve correct path to manifest
            additionalIds.push(innerObject['id']);
        }
        parameters.transferParameters.title = nextDefinition?.title;
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        transferManifestEntriesAndFlexChange(parameters.transferParameters, innerObject, [...ids, ...additionalIds], localIdParts, [...parameters.breadcrumbs, parameters.key], nextDefinition?.targetDefinition);
        parameters.index++;
    }
}
/**
 * Creates an ALP 'views' entry in the resulting manifest if not yet existing.
 * Adds the secondary = table view if missing.
 * @param {TransferParameterTypeV4} transferParameters - list of parameters passed from API
 * @param configObject - current object in config.json
 * @returns
 * - a boolean indicating that the views entry got created.
 * - a boolean indicating if the processing of sub-objects shall be stopped
 **/
function createALPTableView(transferParameters, configObject, key) {
    let newElementCreated = false;
    if (!configObject[key] || Object.keys(configObject[key]).length === 0 || !configObject.chart) {
        return { newElementCreated, stopProcessing: true };
    }
    const path = application_1.getSettingsPathForPage(transferParameters.pageNameArray) + `/views`;
    const views = common_1.getManifestSectionByPathV4(transferParameters.exportResults.manifest, path);
    if (!views['paths'] || Object.keys(views['paths']).length === 0) {
        views['paths'] = [
            {
                secondary: [
                    {
                        annotationPath: configObject[key].annotationPath
                    }
                ]
            }
        ];
        newElementCreated = true;
    }
    else if (!views['paths'][0].secondary) {
        views['paths'][0].secondary = [
            {
                annotationPath: configObject[key].annotationPath
            }
        ];
        newElementCreated = true;
    }
    return { newElementCreated, stopProcessing: false };
}
/**
 * Creates an ALP 'views' entry in the resulting manifest if not yet existing.
 * Adds the primary = chart view if missing.
 * @param {TransferParameterTypeV4} transferParameters - list of parameters passed from API
 * @param configObject - current object in config.json
 * @returns
 * - a boolean indicating that the views entry got created.
 * - a boolean indicating if the processing of sub-objects shall be stopped
 */
function createALPChartView(transferParameters, configObject, key) {
    let newElementCreated = false;
    if (!configObject[key] || Object.keys(configObject[key]).length === 0) {
        return { newElementCreated, stopProcessing: true };
    }
    const path = application_1.getSettingsPathForPage(transferParameters.pageNameArray) + `/views`;
    const views = common_1.getManifestSectionByPathV4(transferParameters.exportResults.manifest, path);
    if (!views['paths'] || Object.keys(views['paths']).length === 0) {
        views['paths'] = [
            {
                primary: [
                    {
                        annotationPath: configObject[key].annotationPath
                    }
                ]
            }
        ];
        newElementCreated = true;
    }
    else if (!views['paths'][0].primary) {
        views['paths'][0].primary = [
            {
                annotationPath: configObject[key].annotationPath
            }
        ];
        newElementCreated = true;
    }
    if (!views['paths'][0].secondary) {
        views['paths'][0].secondary = [
            {
                annotationPath: configObject?.table?.annotationPath || 'com.sap.vocabularies.UI.v1.LineItem'
            }
        ];
    }
    return { newElementCreated, stopProcessing: false };
}
/**
 * Creates an controlConfiguration with filterFields in the resulting manifest if not yet existing.
 * Adds the current visual filters if missing.
 * @param {TransferParameterTypeV4} transferParameters - list of parameters passed from API
 * @param configObject - current object in config.json
 * @returns a boolean indicating that the filter fields entry got created.
 */
function createVisualFilters(transferParameters, configObject) {
    if (!configObject || Object.keys(configObject).length === 0) {
        return false;
    }
    let newElementCreated = false;
    const path = application_1.getSettingsPathForPage(transferParameters.pageNameArray);
    const settings = common_1.getManifestSectionByPathV4(transferParameters.exportResults.manifest, path);
    const SelectionFields = `@${"com.sap.vocabularies.UI.v1.SelectionFields" /* SelectionFields */}`;
    // No visual filters yet
    if (!settings['controlConfiguration']) {
        settings['controlConfiguration'] = { [SelectionFields]: { filterFields: {} } };
        newElementCreated = true;
    }
    else if (!settings['controlConfiguration'][SelectionFields]) {
        settings['controlConfiguration'][SelectionFields] = { filterFields: {} };
        newElementCreated = true;
    }
    else if (!settings['controlConfiguration'][SelectionFields]['filterFields']) {
        settings['controlConfiguration'][SelectionFields]['filterFields'] = {};
        newElementCreated = true;
    }
    if (newElementCreated) {
        const filterFields = settings['controlConfiguration'][SelectionFields]['filterFields'];
        Object.keys(configObject).forEach((filterName) => {
            const filterConfig = configObject[filterName];
            filterFields[filterName] = {};
            for (const property in filterConfig) {
                // Special handling for visualFilterValueList (split)
                if (property === 'visualFilterValueList') {
                    filterFields[filterName]['visualFilter'] = { valueList: filterConfig[property] };
                }
                else {
                    filterFields[filterName][property] = filterConfig[property];
                }
            }
        });
    }
    return newElementCreated;
}
/**
 * Creates an LR 'views' entry in the resulting manifest if not yet existing yet.
 * Adds the current table view if missing.
 * @param {TransferParameterTypeV4} transferParameters - list of parameters passed from API
 * @param configObject - current object in config.json
 * @returns a boolean indicating that the views entry got created.
 */
function createLRTableView(index, transferParameters, key, configObject) {
    if (!configObject || Object.keys(configObject).length === 0) {
        return false;
    }
    let newElementCreated = false;
    const path = application_1.getSettingsPathForPage(transferParameters.pageNameArray) + `/views`;
    const views = common_1.getManifestSectionByPathV4(transferParameters.exportResults.manifest, path);
    const newEntry = {
        key: configObject['key'],
        annotationPath: configObject.annotationPath
    };
    if (!views['paths'] || Object.keys(views['paths']).length === 0) {
        //No views yet
        views['paths'] = [newEntry];
        newElementCreated = true;
    }
    else {
        const existingIndex = views['paths'].findIndex((view) => view.key === configObject['key'] || view.key === key);
        if (existingIndex === -1) {
            //Given view does not exist yet
            views['paths'].push(newEntry);
            newElementCreated = true;
        }
        else if (existingIndex !== configObject.index) {
            //Reordering scenario
            const savedContent = JSON.parse(JSON.stringify(views['paths'][existingIndex]));
            views['paths'].splice(existingIndex, 1);
            views['paths'].splice(index, 0, savedContent);
            newElementCreated = true;
        }
    }
    return newElementCreated;
}
/**
 * Special logic to create new elements in manifest
 * @param definitionName - schema definition name of the current object
 * @param key - key of the current object
 * @param configObject - current object in config.json
 * @param breadcrumbs - array of sequence of properties that we are currently processing. Required for instance for table column name
 * @param {TransferParameterTypeV4} transferParameters - list of parameters passed from API
 * @returns newElementCreated - boolean value to indicate that a new element was created ==> no further sync rule on this level
 */
function createNewElement(index, definitionName, key, configObject, breadcrumbs, transferParameters, preprocessed = false) {
    let newElementCreated = false;
    const stopProcessing = false;
    if (definitionName && !preprocessed) {
        if (definitionName.startsWith(ux_specification_types_1.DefinitionName.CustomColumn)) {
            newElementCreated = exportCustomColumn_1.createNewCustomColumn(key, transferParameters, configObject[key], transferParameters.logger, breadcrumbs);
        }
        else if (definitionName === ux_specification_types_1.DefinitionName.ALPChartView && key === ux_specification_types_1.PropertyName.chart && configObject) {
            return createALPChartView(transferParameters, configObject, key);
        }
        else if (definitionName === ux_specification_types_1.DefinitionName.ALPTableView && key === ux_specification_types_1.PropertyName.table && configObject) {
            return createALPTableView(transferParameters, configObject, key);
        }
        else if (key &&
            (definitionName.startsWith(ux_specification_types_1.DefinitionName.LRTableView) ||
                definitionName.startsWith(ux_specification_types_1.DefinitionName.LRChartView))) {
            newElementCreated = createLRTableView(index, transferParameters, key, configObject[key]);
        }
        else if (key && definitionName.startsWith(ux_specification_types_1.DefinitionName.VisualFilters)) {
            newElementCreated = createVisualFilters(transferParameters, configObject[key]);
        }
    }
    return { newElementCreated, stopProcessing };
}
/**
 * Transfers one entry of a list (aka one property of the config) to the manifest
 * @param {TransferEntryParameters} parameters - list of parameters
 * @param parentIds - array of collected parent ids
 * @param stableIdParts - list of parts of the stable ID for flex changes
 * @param preprocessed - indicates that the list was already preprocessed by following the config order
 */
function transferSortedListEntry(parameters, parentIds, stableIdParts, preprocessed = false) {
    const currentConfigObject = parameters.configObject[parameters.key];
    const childId = common_1.getChildId(parameters.configObject, parameters.key);
    const nextDefinition = utils_1.getNextTargetDefinition(parameters.transferParameters.appSchema, parameters.transferParameters.title, currentConfigObject, parameters.propertyDefinition, parameters.key, parameters.transferParameters.factory, parameters.transferParameters.pageType);
    const { newElementCreated, stopProcessing } = createNewElement(parameters.index, parameters.propertyDefinition.$ref?.split(common_1.DEFINITION_LINK_PREFIX)[1], parameters.key, parameters.configObject, parameters.breadcrumbs, parameters.transferParameters, preprocessed);
    const ids = childId ? [...parentIds, childId] : [...parentIds, parameters.key];
    if (!newElementCreated) {
        evaluateExportRule(parameters.transferParameters, parameters.breadcrumbs, parameters.key, parameters.configObject, ids, parameters.propertyDefinition, nextDefinition);
    }
    if (parameters.propertyDefinition &&
        ((typeof currentConfigObject === 'object' && Object.keys(currentConfigObject).length !== 0) ||
            (parameters.propertyDefinition.$ref && nextDefinition.configObject)) &&
        !stopProcessing) {
        const localIdParts = childId ? [...stableIdParts, childId] : stableIdParts;
        transferSubObject(parameters, nextDefinition, currentConfigObject, ids, localIdParts);
    }
}
/**
 * Function for special handling of anyOf definitions during the export
 * @param {TransferEntryParameters} parameters - list of parameters
 * @param anyOfDefinitions - the array of definitions from the anyOf (of additionalProperties)
 * @param schemaDefinition - parent definition, comprising properties as well as additionalProperties
 * @param parentIds - array of collected parent ids
 * @param stableIdParts - list of parts of the stable ID for flex changes
 * @returns
 */
function transferConfigEntriesWithAnyOfDefinitions(transferEntryParameters, anyOfDefinitions, schemaDefinition, parentIds, stableIdParts) {
    let preprocessed = false;
    if (anyOfDefinitions) {
        const configEntries = Object.entries(transferEntryParameters.configObject);
        if (!configEntries || configEntries.length < 1) {
            return preprocessed;
        }
        configEntries.sort((a, b) => a[1]['index'] - b[1]['index']);
        //follow the config order, to support reordering
        configEntries.forEach((configEntry) => {
            if (schemaDefinition.properties[configEntry[0]]) {
                transferEntryParameters.key = configEntry[0];
                transferEntryParameters.propertyDefinition = schemaDefinition.properties[configEntry[0]];
                //already part of schema
                transferSortedListEntry(transferEntryParameters, parentIds, stableIdParts);
                preprocessed = true;
            }
            else if (typeof configEntry[1] === 'object') {
                //match against potential schema definitions
                anyOfDefinitions.forEach((anyOfDefinition) => {
                    if (anyOfDefinition.$ref) {
                        transferEntryParameters.key = configEntry[0];
                        transferEntryParameters.propertyDefinition = anyOfDefinition;
                        transferSortedListEntry(transferEntryParameters, parentIds, stableIdParts);
                        preprocessed = true;
                    }
                });
            }
            transferEntryParameters.index++;
        });
    }
    return preprocessed;
}
/**
 * Method updates list of definition entries from schema with entries for insertion based on `additionalProperties` entry.
 * @param {TransferParameterTypeV4} transferParameters - list of parameters passed from API.
 * @param {Definition} additionalProperties - allowed additional properties.
 * @param {[string, DefinitionOrBoolean][]} list - list with entries.
 * @param {{ [key: string]: unknown }} configObject - configuration object.
 */
function mergeEntriesForInsert(transferParameters, additionalProperties, list, configObject) {
    let properties = additionalProperties?.properties;
    let required = additionalProperties?.required;
    if (!properties && additionalProperties?.$ref) {
        const reference = additionalProperties?.$ref;
        const definition = transferParameters.appSchema.definitions[reference.split(common_1.DEFINITION_LINK_PREFIX)[1]];
        if (typeof definition === 'object') {
            properties = definition.properties;
            required = definition.required;
        }
    }
    if (!properties) {
        return;
    }
    required = required || [];
    // Merge new entries for creation into list
    for (const key in configObject) {
        const entry = configObject[key];
        // Check if entry from config does not exist in list - potential insert.
        // Additionally check if interface of config entry matches additionalProperties - all required properties should exist in entry
        if (typeof entry === 'object' &&
            !list.some((item) => item[0] === key) &&
            required.every((property) => entry[property])) {
            list.push([key, additionalProperties]);
        }
    }
}
/**
 * Recursive function that traverses the content of the current object. It reads decorators and fills exportResultManifest entries and flex changes
 * @param {TransferParameterTypeV4} transferParameters - list of parameters passed from API
 * @param configObject - current object to traverse
 * @param parentIds - array of collected parent ids
 * @param stableIdParts - list of parts of the stable ID for flex changes
 * @param breadcrumbs - array of sequence of properties that we are currently processing. Required for instance for table column name
 * @param schemaDefinition - the current entry point or definition in the app schema
 * @param title - the title to be used for the given schema definition
 */
function transferManifestEntriesAndFlexChange(transferParameters, configObject, parentIds, stableIdParts, breadcrumbs, schemaDefinition) {
    if (!schemaDefinition?.properties) {
        return;
    }
    let index = 0;
    //In case of additionalProperties = flexible array definition ==> new entries from the config shall be exported too
    const transferEntryParameters = {
        transferParameters,
        breadcrumbs,
        key: undefined,
        index,
        configObject,
        propertyDefinition: undefined
    };
    const additionalProperties = schemaDefinition.additionalProperties;
    const anyOfDefinitions = additionalProperties?.anyOf;
    const preprocessed = transferConfigEntriesWithAnyOfDefinitions(transferEntryParameters, anyOfDefinitions, schemaDefinition, parentIds, stableIdParts);
    //Sort if there is a propertyIndex, so that the exported list ends up in manifest in the right order
    let sortedList = schemaDefinition.properties && Object.entries(schemaDefinition.properties);
    if (sortedList) {
        if (sortedList[0]?.[1][ux_specification_types_1.SchemaTag.propertyIndex]) {
            sortedList = Object.entries(schemaDefinition.properties).sort((a, b) => a[1][ux_specification_types_1.SchemaTag.propertyIndex] - b[1][ux_specification_types_1.SchemaTag.propertyIndex]);
        }
        if (additionalProperties?.$ref) {
            // Merge new entries for creation into list
            mergeEntriesForInsert(transferParameters, additionalProperties, sortedList, configObject);
        }
        index = 0;
        sortedList.forEach((element) => {
            transferEntryParameters.key = element[0];
            transferEntryParameters.propertyDefinition = element[1];
            transferEntryParameters.index = index;
            transferSortedListEntry(transferEntryParameters, parentIds, stableIdParts, preprocessed);
            if (element[1].$ref) {
                index++;
            }
        });
    }
}
/**
 * Instantiates the export classes for a single object page section
 * @param sectionId - Current section ID
 */
function getClassesForSingleSection(objectPageConfig, sectionId, factory) {
    if (sectionId === 'custom' && Array.isArray(objectPageConfig.sections[sectionId])) {
        // Custom sections
        const customSections = objectPageConfig.sections
            .custom;
        for (let index = 0; index < customSections.length; index++) {
            customSections[index] = factory.createInstance(ux_specification_types_1.PageTypeV2.ObjectPage, 'ObjectPageCustomSectionView', customSections[index], customSections[index].className);
        }
    }
}
/**
 * Recursive sub-function for handling subsections
 * @param section - Object page section in config
 */
function getSubsectionClasses(section, factory) {
    if (section['subsections']) {
        let subSection;
        for (const subSectionId in section['subsections']) {
            subSection = section['subsections'][subSectionId];
            getClassesForSingleSection(subSection, subSectionId, factory);
            getSubsectionClasses(subSection, factory);
        }
    }
}
/**
 * Instantiates the export classes for the object page section
 * @param objectPageConfig - the given object page configuration
 * @param objectPage - the overall object page export class where the sections shall be included
 */
function getExportClassesForSections(objectPageConfig, objectPage, factory) {
    let section;
    for (const sectionId in objectPageConfig.sections) {
        section = objectPage.sections[sectionId];
        getClassesForSingleSection(objectPageConfig, sectionId, factory);
        getSubsectionClasses(section, factory);
    }
}
/**
 * Run through the given ObjectPage config and return respective exportResultManifest entry and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param objectPageConfig - content of the src/ObjectPage_<entity_set>.json file
 * @param manifest - manifest of the application
 * @param pageName - routing target defined in manifest
 */
const exportObjectPage = (exportParameters, ui5Version) => {
    const exportResults = exports.defaultExportResult;
    exportResults.manifest = JSON.parse(JSON.stringify(exportParameters.manifest));
    const factory = new factory_1.MetadataInstanceFactoryV4();
    const objectPage = factory.createPageInstance(ux_specification_types_1.PageTypeV2.ObjectPage, exportParameters.page.config);
    const pageLayoutInformation = common_1.getPageLayoutInformation(objectPage);
    const pageName = exportParameters.page.name;
    const baseId = `${exportParameters.appId}::${pageLayoutInformation.id}::${pageName}--`;
    if (exportParameters.page.config?.[ux_specification_types_1.PropertyName.sections]) {
        getExportClassesForSections(exportParameters.page.config, objectPage, factory);
    }
    const transferParameters = {
        exportResults,
        appId: exportParameters.appId,
        appRootPath: exportParameters.appRootPath,
        baseId,
        appSchema: exportParameters.jsonSchema,
        config: objectPage,
        ui5Version,
        factory,
        pageNameArray: [pageName],
        pageType: ux_specification_types_1.PageTypeV4.ObjectPage,
        title: undefined,
        templateType: ux_specification_types_1.TemplateType.ListReportObjectPageV4
    };
    transferManifestEntriesAndFlexChange(transferParameters, objectPage, [], //no parentIds
    [], // no stableIds
    [], // no breadcrumbs
    exportParameters.jsonSchema //starting point for target definition
    );
    return exportResults;
};
/**
 * Run through the given List Page (LR or ALP) config and return respective exportResultManifest entry and flex changes
 * @param {ExportListReportV4Parameters} exportParameters - all API parameters needed for the export
 * @param config - content of the config file
 * @param {PageTypeV4} - pageType - Page type
 * @param ui5Version - SAP UI5 version
 */
const exportListPage = (exportParameters, factory, config, pageType, ui5Version, templateType) => {
    const exportResults = exports.defaultExportResult;
    exportResults.manifest = JSON.parse(JSON.stringify(exportParameters.manifest));
    const appSchema = exportParameters.jsonSchema;
    const definitionName = config.table?.[ux_specification_types_1.PropertyName.annotationPath]
        ? ux_specification_types_1.DefinitionName.ALPTableView
        : ux_specification_types_1.DefinitionName.Table;
    const tableDefinition = (config.table = factory.createInstance(pageType, definitionName, config.table));
    let tableDefinitionName = ux_specification_types_1.DefinitionName.LineItems;
    if (appSchema.definitions[ux_specification_types_1.DefinitionName.TableSPV]) {
        const tableRef = appSchema.definitions[ux_specification_types_1.DefinitionName.TableSPV].properties.columns['$ref'];
        tableDefinitionName = tableRef.split(common_1.DEFINITION_LINK_PREFIX)[1];
    }
    const appSchemaActions = appSchema.definitions[`${ux_specification_types_1.DefinitionName.Actions}<${tableDefinitionName}>`];
    if (tableDefinition.toolBar?.actions && appSchemaActions) {
        for (const actionKey in appSchemaActions.properties) {
            tableDefinition.toolBar.actions[actionKey] = factory.createInstance(pageType, ux_specification_types_1.DefinitionName.ToolBarAction, tableDefinition.toolBar.actions[actionKey]);
        }
    }
    const pageLayoutInformation = common_1.getPageLayoutInformation(config);
    const pageName = exportParameters.page.name;
    const baseId = `${exportParameters.appId}::${pageLayoutInformation.id}::${pageName}--`;
    const transferParameters = {
        exportResults,
        appId: exportParameters.appId,
        appRootPath: exportParameters.appRootPath,
        baseId,
        appSchema,
        config,
        ui5Version,
        factory,
        pageNameArray: [pageName],
        pageType: ux_specification_types_1.PageTypeV4.ListReport,
        title: undefined,
        logger: exportParameters.logger,
        templateType
    };
    transferManifestEntriesAndFlexChange(transferParameters, config, [], //no parentIds
    [], // no stableIds
    [], // no breadcrumbs
    appSchema //starting point for target definition
    );
    return exportResults;
};
/**
 * Run through the given ListReport config and return respective exportResultManifest entry and flex changes
 * @param {ExportListReportV4Parameters} exportParameters - all API parameters needed for the export
 * @param ui5Version - SAP UI5 version
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
const exportListReportPage = (exportParameters, ui5Version, templateType) => {
    const factory = new factory_1.MetadataInstanceFactoryV4();
    const listReport = factory.createPageInstance(ux_specification_types_1.PageTypeV2.ListReport, exportParameters.page.config);
    return exportListPage(exportParameters, factory, listReport, ux_specification_types_1.PageTypeV4.ListReport, ui5Version, templateType);
};
/**
 * Run through the given Analytical List Page config and return respective exportResultManifest entry and flex changes
 * @param {ExportAnalyticalListPageV4Parameters} exportParameters - all API parameters needed for the export
 * @param ui5Version - SAP UI5 version
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 *
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
const exportAnalyticalListPage = (exportParameters, ui5Version) => {
    return exportListReportPage(exportParameters, ui5Version, ux_specification_types_1.TemplateType.AnalyticalListPageV4);
};
/**
 * API for the export of a V4 app configuration
 * Export means the transfer of the properties and values of the given config to manifest entries or flex changes
 * @param application - V4 application (app.json config file)
 * @param manifest - Manifest of the given app
 * @param appSchema - App schema
 *
 * @returns ExportResults = object comprising the updated manifest and a list of flex changes
 */
const exportApplicationV4 = (application, manifest, appSchema) => {
    const exportResults = exports.defaultExportResult;
    exportResults.manifest = JSON.parse(JSON.stringify(manifest));
    const applicationV4 = Object.assign(new application_1.ApplicationV4(), application);
    //transform application settings
    applicationV4.settings = Object.assign(new application_1.AppSettings(), applicationV4.settings);
    for (const key in appSchema.definitions.AppSettings.properties) {
        const syncRule = common_1.getReflectMetadata(applicationV4.settings, key);
        if (syncRule && syncRule.manifest) {
            const path = syncRule.manifest.path();
            const manifestSection = common_1.getManifestSectionByPathV4(exportResults.manifest, path);
            if (syncRule.manifest.export) {
                const exportParams = {
                    exportHandler: syncRule.manifest.export,
                    manifestSection,
                    configObject: application,
                    configPropertyKey: key,
                    manifestKey: key,
                    syncRuleKey: key
                };
                const propertyDefinition = appSchema.definitions.AppSettings.properties[key];
                transferPropertyToManifest(exportParams, propertyDefinition, {});
            }
            else {
                if (application.settings?.[key] !== undefined) {
                    manifestSection[key] = application.settings[key];
                }
                else {
                    delete manifestSection[key];
                    utils_1.deleteEmptyStructure(exportResults.manifest, path);
                }
            }
        }
    }
    //transform routing
    exportResults.manifest[ux_specification_types_1.ManifestSection.ui5].routing = manifest_1.transformRoutingV4(application['home'], application['pages'], exportResults.manifest);
    // Update FCL data
    flexibleColumnLayout_1.updateFcl(exportResults.manifest[ux_specification_types_1.ManifestSection.ui5], application);
    return exportResults;
};
/**
 * General API for the export of a V4 config page
 * Export means the transfer of the properties and values of the given config to manifest entries or flex changes
 * @param appId - Application ID
 * @param page - Current page (config)
 * @param manifest - Manifest of the given app
 * @param jsonSchema - App schema
 *
 * @returns ExportResults = object comprising the updated manifest and a list of flex changes
 */
const exportPageV4 = (exportParametersV4, ui5Version) => {
    if (exportParametersV4[ux_specification_types_1.SchemaType.ListReport]) {
        return exportListReportPage(exportParametersV4[ux_specification_types_1.SchemaType.ListReport], ui5Version, ux_specification_types_1.TemplateType.ListReportObjectPageV4);
    }
    else if (exportParametersV4[ux_specification_types_1.SchemaType.ObjectPage]) {
        return exportObjectPage(exportParametersV4[ux_specification_types_1.SchemaType.ObjectPage], ui5Version);
    }
    else if (exportParametersV4[ux_specification_types_1.SchemaType.Application]) {
        const { application, manifest, jsonSchema } = exportParametersV4[ux_specification_types_1.SchemaType.Application];
        return exportApplicationV4(application, manifest, jsonSchema);
    }
    else if (exportParametersV4[ux_specification_types_1.SchemaType.AnalyticalListPage]) {
        return exportAnalyticalListPage(exportParametersV4[ux_specification_types_1.SchemaType.AnalyticalListPage], ui5Version);
    }
    else if (exportParametersV4[ux_specification_types_1.SchemaType.FPMCustomPage]) {
        return fpmCustomPage_1.exportFPMCustomPageConfig(exportParametersV4[ux_specification_types_1.SchemaType.FPMCustomPage], exports.defaultExportResult);
    }
};
exports.exportPageV4 = exportPageV4;
//# sourceMappingURL=export.js.map